{
  "comments": [
    {
      "key": {
        "uuid": "ba63aebe_b105734d",
        "filename": "libc/include/android/dlext.h",
        "patchSetId": 4
      },
      "lineNbr": 217,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-28T19:30:21Z",
      "side": 1,
      "message": "Do you expect anyone else to use this call other than native zygote?  Assuming not, might as well be explicit that it shouldn\u0027t be used besides that use case.",
      "revId": "e45e3a4b9b622a91b6deeb072e220d5a0a812a48",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06dc6a72_1fd9ab63",
        "filename": "libdl/libdl.map.txt",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-28T19:30:21Z",
      "side": 1,
      "message": "Similarly, this exposes this symbol widely, right?  Can this be LIBC_PRIVATE or LIBC_PLATFORM, aka whichever would allow native zygote to use this symbol without exposing it to apps and putting it into the NDK?",
      "revId": "e45e3a4b9b622a91b6deeb072e220d5a0a812a48",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f6e6d89_c330f4c4",
        "filename": "libdl/libdl.map.txt",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1349653
      },
      "writtenOn": "2019-05-28T20:47:08Z",
      "side": 1,
      "message": "That\u0027s a good point. If I make this LIBC_PLATFORM, how can I tell the build system to *not* link against the stub library, which doesn\u0027t contain LIBC_PLATFORM symbols?",
      "parentUuid": "06dc6a72_1fd9ab63",
      "revId": "e45e3a4b9b622a91b6deeb072e220d5a0a812a48",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe948041_ff0d78e5",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 378,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2019-05-28T23:33:35Z",
      "side": 1,
      "message": "I think this CL is treating the second executable like a dlopen\u0027ed DSO, so it\u0027s configured to use dynamic TLS rather than static TLS? I don\u0027t think that\u0027s currently going to work -- the static linker can generate executables that access TLS variables without using a relocation or a function call, e.g.:\n\nhttps://android.googlesource.com/platform/bionic/+/master/docs/elf-tls.md#Local-Exec-LE\n\nI think it\u0027d require toolchain support (and build system changes) to produce executables whose TLS segment is assumed to be allocated dynamically.\n\nELF TLS isn\u0027t enabled in the platform yet, so this issue won\u0027t come up for now.",
      "revId": "e45e3a4b9b622a91b6deeb072e220d5a0a812a48",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0b0365a_d95ae52d",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 378,
      "author": {
        "id": 1349653
      },
      "writtenOn": "2019-05-29T03:58:32Z",
      "side": 1,
      "message": "Thanks for the info! Reading the doc, I\u0027m a bit confused about how the compiler decides whether to use IE/LE vs GD/LD for DSOs. How does the compiler know whether a DSO is ever dlopen()\u0027ed at runtime? Asking because if DSOs on Android are all using GD/LD, we can have a special mode that tells the dynamic linker to only allocate the main executable in the static TLS block, and thus we can just replace the static TLS block when we load the second executable. Is that a feasible approach?",
      "parentUuid": "fe948041_ff0d78e5",
      "revId": "e45e3a4b9b622a91b6deeb072e220d5a0a812a48",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8e083c3_7a9eaba7",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 378,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2019-05-29T23:28:37Z",
      "side": 1,
      "message": "If code is compiled with -fpic, then the compiler assumes its output is going into a DSO, and it uses LD/GD. (The programmer can specify a more efficient model using the `tls_model` attribute or the `-ftls-model` command-line argument, but then they\u0027re responsible for ensuring that the DSO is loaded at startup. dlopen fails with an error code if it tries to load a DSO using static TLS.)\n\n\u003e ... Is that a feasible approach?\n\nI think that approach works as long as the first executable doesn\u0027t use TLS. We would need to do something about the bionic_tls structure, which is currently allocated as part of static TLS. Bionic\u0027s pthread keys (bionic_tls::key_data) are currently allocated just after the executable\u0027s TLS for compatibility with the Golang runtime (https://github.com/golang/go/issues/29674).",
      "parentUuid": "d0b0365a_d95ae52d",
      "revId": "e45e3a4b9b622a91b6deeb072e220d5a0a812a48",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}