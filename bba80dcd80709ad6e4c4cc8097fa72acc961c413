{
  "comments": [
    {
      "key": {
        "uuid": "43667548_bd1bc780",
        "filename": "libc/bionic/malloc_common_dynamic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 532,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-02-12T01:27:09Z",
      "side": 1,
      "message": "I didn\u0027t realize this before, but this is actually incorrect. I would suggest putting this into a function and follow the model that is going on in EnableLimitDispatchTable (the non-static version).\n\nThe code in the static executable needs to add a mutex lock and getting it because now two different threads could call mallopt at the same time and try to mutate the globals at the same time. The old limit code was designed to avoid that situation, so it didn\u0027t need the lock. I think the gGlobalsMutateLock needs to move to malloc_common.h and malloc_common.cpp, then for the static version, add a lock before doing the mutate, and add a lock in EnableLimitDispatchTable static version.",
      "range": {
        "startLine": 532,
        "startChar": 4,
        "endLine": 532,
        "endChar": 52
      },
      "revId": "bba80dcd80709ad6e4c4cc8097fa72acc961c413",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95d34455_fa443bfe",
        "filename": "libc/bionic/malloc_common_dynamic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 532,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2020-02-12T01:30:25Z",
      "side": 1,
      "message": "M_INITIALIZE_GWP_ASAN is only callable before any threads have spawned (https://cs.android.com/android/platform/superproject/+/master:bionic/libc/bionic/gwp_asan_wrappers.cpp;l\u003d213), so I don\u0027t think this affects us here.",
      "parentUuid": "43667548_bd1bc780",
      "range": {
        "startLine": 532,
        "startChar": 4,
        "endLine": 532,
        "endChar": 52
      },
      "revId": "bba80dcd80709ad6e4c4cc8097fa72acc961c413",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8436b3d9_e12afdea",
        "filename": "libc/bionic/malloc_common_dynamic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 532,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-02-12T01:49:30Z",
      "side": 1,
      "message": "I worry that this could escalate to a security issue. Obviously, crashing your own process isn\u0027t a big deal, but if you could somehow force a high privilege process to somehow do a call to this while trying to enable heapprofd, you could cause it to crash, or something more nefarious. And some malicious code can do some really clever things, so it seems better to err on the side of caution and avoid this problem completely. And sometimes an attack only needs to find a way to crash some process reliably to trigger an attack.\n\nI don\u0027t think it\u0027s too hard to plug this hole. If it starts to get tricky, then it might be worth doing something not as hard.\n\nI also wouldn\u0027t be opposed to you submiting this, and I\u0027ll fix the potential races in a subsequent cl.",
      "parentUuid": "95d34455_fa443bfe",
      "range": {
        "startLine": 532,
        "startChar": 4,
        "endLine": 532,
        "endChar": 52
      },
      "revId": "bba80dcd80709ad6e4c4cc8097fa72acc961c413",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}