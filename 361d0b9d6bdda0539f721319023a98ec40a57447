{
  "comments": [
    {
      "key": {
        "uuid": "9cd76f7e_1944d70b",
        "filename": "libdl/libdl.c",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1041673
      },
      "writtenOn": "2016-05-30T19:04:39Z",
      "side": 1,
      "message": "no - default and anonymous namespaces cannot be exposed, they are reserved for bionic-use only.",
      "revId": "361d0b9d6bdda0539f721319023a98ec40a57447",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cd76f7e_84a97a8b",
        "filename": "libdl/libdl.c",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1104175
      },
      "writtenOn": "2016-05-31T01:18:03Z",
      "side": 1,
      "message": "the emulated subsystem needs access to all native libraries. With namespace introduced, the subsystem needs access to libraries in every namespaces, that\u0027s why we need the key of default and anonymous namespace. And we have no other better solution.\n\nHere are the two possible solutions we have evaluated:\n1. current design - expose the key of default and anonymous. native bridge doesn\u0027t need the pointer necessarily, but a key is needed.\n2. expose the structure android_namespace_t - if you are insisted on hiding these two namespaces, we can play tricks. The disadvantage is that, the callback in native loader, which is responsible for loading library for native bridge, will be deprecated. In this way, android_namespace_t will be exposed.\n\nSo, basically, as far as we can understand, the problem is exposing either android_namespace_t or default/anonymous namespace. You guys are the expert, can you give us a hint of another better solution?",
      "parentUuid": "9cd76f7e_1944d70b",
      "revId": "361d0b9d6bdda0539f721319023a98ec40a57447",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cd76f7e_e4d156e2",
        "filename": "libdl/libdl.c",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1041673
      },
      "writtenOn": "2016-05-31T04:15:34Z",
      "side": 1,
      "message": "I do not think it does... if we reflect calls to nb implementation it should be able to do everything without access to host system default/anonymous namespace: \n\nNote that since NB application does not really have any of host arch libraries there is no need to create namespaces with host linker and therefore there is no anonymous namespace for such apps.",
      "parentUuid": "9cd76f7e_84a97a8b",
      "revId": "361d0b9d6bdda0539f721319023a98ec40a57447",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cd76f7e_04e46ab2",
        "filename": "libdl/libdl.c",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1104175
      },
      "writtenOn": "2016-05-31T04:31:00Z",
      "side": 1,
      "message": "why you think \"if we reflect calls to nb implementation it should be able to do everything without access to host system default/anonymous namespace\". Can a ABI matched app runs without the default/anonymous namespace in linker? Obviously not. So native bridge needs default/anonymous and they must be peered with dynamic linker\u0027s.\n\n\u003e\u003e\u003e Note that since NB application does not really have any of host arch libraries there is no need to create namespaces with host linker\n1. Apps could packed cross ABI libs, it will check ABI and load libs of matched ABI.\n2. We are trying to make you guys notice this - native bridge really loads libs of different ABIs, one is by itself and another is by dynamic linker. This is a generic fact, no matter what the apps running in subsystem does. This \"assumption\" is hidden since before namespace introduced, dlopen is enough for us.",
      "parentUuid": "9cd76f7e_e4d156e2",
      "revId": "361d0b9d6bdda0539f721319023a98ec40a57447",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59598944_c89a2f73",
        "filename": "libdl/libdl.c",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2016-05-31T16:26:12Z",
      "side": 1,
      "message": "Zhenhua, as we discussed in the email, please provide test cases that fail and are addressed by this solution. It seems that you are aware of corner cases that we could have missed. If so, it should be easy for you to expose those in tests. After that, we can then consider what\u0027s the best solution.\n\nAt this point we are just re-iterating what we already discuss. So let\u0027s focus on having tests first.",
      "parentUuid": "9cd76f7e_04e46ab2",
      "revId": "361d0b9d6bdda0539f721319023a98ec40a57447",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59a269c0_c3862829",
        "filename": "libdl/libdl.c",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1104175
      },
      "writtenOn": "2016-06-02T02:25:27Z",
      "side": 1,
      "message": "Maybe we can give you a test, but the existed cases passed on cross ABI environment is only because our native bridge implementation has workaround for the lack of namespace support at native bridge side. We don\u0027t want to workaround it in future, so we prefer a clear API here and don\u0027t like any hidden assumption of ART/dynamic linker, since they are not standard/specification of Android project. Anyway, we will do our work.",
      "parentUuid": "59598944_c89a2f73",
      "revId": "361d0b9d6bdda0539f721319023a98ec40a57447",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}