{
  "comments": [
    {
      "key": {
        "uuid": "AAAEsn////s\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 9,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T09:22:05Z",
      "side": 1,
      "message": "I think I would prefer to see these implementation details (and documentation reference) directly in the source code itself, rather than the commit message. It will help maintenance in the long term.\n\nThe commit message could still say something like \"the root of the problem is that the existing implementation is based on the ARM C++ ABI, which mandates a different guard variable layout than the Itanium/x86 C++ one.\"",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEsn////k\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T09:22:05Z",
      "side": 1,
      "message": "Actually, you can #include \u003csys/endian.h\u003e and use _BYTE_ORDER which will be one of _LITTLE_ENDIAN, _BIG_ENDIAN or _PDP_ENDIAN (yeah, unlikely :-))",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAErH////k\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1011068
      },
      "writtenOn": "2012-04-12T09:41:18Z",
      "side": 1,
      "message": "Thanks for pointing this.\nWe may not need to check the _BYTE_ORDER. Just use letoh32 here should be ok. Right?",
      "parentUuid": "AAAEsn////k\u003d",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEsn////U\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T10:44:05Z",
      "side": 1,
      "message": "yes, looking at the code in \u003csys/endian.h\u003e, that should be usable in constant expressions (i.e. it won\u0027t generate a function call).",
      "parentUuid": "AAAErH////k\u003d",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEsn////o\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T09:22:05Z",
      "side": 1,
      "message": "I think the definitions above and how they are used below could be simplified. There is no need to require constant typecasts between _guard_t and _guard_u types. A single type should be enough, for example:\n\n  #if defined(__arm__)\n  // The ARM C++ ABI mandates that guard variable are\n  // 32-bit aligned, 32-bit values. And only its LSB is tested by\n  // the compiler-generated code before calling \n  // __cxa_guard_acquire.\n  //\n  typedef union {\n    int volatile state;\n    int32_t aligner;\n  } guard_t;\n\n  const static int ready \u003d 0x1;\n  const static int pending \u003d 0x2;\n  const static int waiting \u003d 0x6;\n\n  #elif defined(__i386__)\n  // The Itanium/x86 C++ ABI mandates that guard variables\n  // are 64-bit aligned, 64-bit values. Also, the least-significant\n  // byte is tested by the compiler-generated code before, we calling\n  // __cxa_guard_acquire. We can access it through the first\n  // 32-bit word in the union below.\n  //\n  typedef union {\n    int volatile state;\n    int64_t aligner;\n  } guard_t;\n\n  const static int ready \u003d 0x1;\n  const static int pending \u003d 0x100;\n  const static int waiting \u003d 0x10000;\n\n  #else\n  // Avoid generating bad code when this source is ported to a\n  // a new CPU architecture.\n  #  error Unknown CPU architecture. Please update this source with the right C++ ABI support.\n  #endif\n\nThen later, usage simply becomes:\n\n  ... __cxa_guard_acquire(guard_t* gv)\n  {\n    if (__atomic_cmpxchg(0, pending, \u0026gv-\u003estate) \u003d\u003d 0) {\n       ...\n    }\n    ...\n  }",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAErH////g\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 1011068
      },
      "writtenOn": "2012-04-12T09:41:18Z",
      "side": 1,
      "message": "We tried to avoid include the large block in #if ... #else... #endif. :).\n\nAnd does this change break MIPS? Our change will not impact MIPS.",
      "parentUuid": "AAAEsn////o\u003d",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEsn////Q\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T10:44:05Z",
      "side": 1,
      "message": "Actually, I tried looking for the MIPS C++ ABI after sending my last review. I couldn\u0027t find one online, but on the other hand, the GCC 4.6 sources seem to indicate that it follows the generic one (i.e. 64-bit aligned 64-bit values, testing of the first _byte_, independent of endianess).\n\nThe GNU libstdc++ uses the following trick to compute the ready/pending/waiting values: an inline function that returns the value corresponding to the n-th byte of an int, something like:\n\n  static inline int __get_guard_bit(int bytenum) {\n    union { int i; char c[sizeof(int)]; } u \u003d { 0 };\n    u.c[bytenum] \u003d 1;\n    return u.i\n  }\n\n  #define  _READY_BIT   __get_guard_bit(0)\n  #define  _PENDING_BIT __get_guard_bit(1)\n  #define  _WAITING_BIT  __get_guard_bit(2)\n\nThis avoids checking for endianess explicitely. On the other hand, it relies on the compiler to properly optimize all computations (also the code doesn\u0027t use any static const int values, probably to avoid generating static initializers).\n\nI\u0027m not sure we want to use this here. letoh32() seems to be just fine and portable enough for me.\n\nIn all cases, it means we should be able to use the same block for defined(__i386__) and defined(__mips__)",
      "parentUuid": "AAAErH////g\u003d",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEsn////c\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 49,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T09:22:05Z",
      "side": 1,
      "message": "since this is a C++ source file, you probably want to use reinterpret_cast\u003c\u003e here to avoid compiler warnings.",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAErH////c\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 49,
      "author": {
        "id": 1011068
      },
      "writtenOn": "2012-04-12T09:41:18Z",
      "side": 1,
      "message": "New patchset will use the definition you suggested.",
      "parentUuid": "AAAEsn////c\u003d",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEsn////g\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 81,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-04-12T09:22:05Z",
      "side": 1,
      "message": "you probably meant \"_guard_t volatile * gv\" here.",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAErH////Y\u003d",
        "filename": "libstdc++/src/one_time_construction.cpp",
        "patchSetId": 4
      },
      "lineNbr": 81,
      "author": {
        "id": 1011068
      },
      "writtenOn": "2012-04-12T09:41:18Z",
      "side": 1,
      "message": "Yeah. Right. We mean \"_guard_t\" instead of int",
      "parentUuid": "AAAEsn////g\u003d",
      "revId": "abe842104d2d481b35a8b7e06600ae8b1363c739",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}