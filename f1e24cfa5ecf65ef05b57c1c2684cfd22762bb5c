{
  "comments": [
    {
      "key": {
        "uuid": "54615c3d_e3a7f8c3",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-01T02:31:59Z",
      "side": 1,
      "message": "Won\u0027t this resend the signal before mainline code has made any progress? Thus if you interrupted a thread holding the gGlobalsMutating \"lock\", wouldn\u0027t you immediately hit that case again?",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1bea25b_4fb96fbe",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-07T18:57:03Z",
      "side": 1,
      "message": "It should only ever resend the signal once. The code in the other thread blocks the signal, so the only way you can get to this point is if the signal is now blocked (and will resend when it\u0027s unblocked in the other thread).",
      "parentUuid": "54615c3d_e3a7f8c3",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e34a50fa_dfdb5419",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-08T01:33:34Z",
      "side": 1,
      "message": "I think I\u0027m misunderstanding something here. I concluded last time that this is called from a signal handler, and you\u0027re going through the atomic_exchange locking to make that safe in the event you interrupted ?\n\nThus my conclusion was that raising the signal here would cause the signal handler to exit and reenable the signal, at which point, the signal handler would be immediately reinvoked. I don\u0027t think the interrupted thread will have had a chance to advance at that point.\n\nWhat did I miss?",
      "parentUuid": "a1bea25b_4fb96fbe",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6ccd096_94b4b8ac",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-11T22:58:21Z",
      "side": 1,
      "message": "Here\u0027s the only sequence that can involve causing a raise, or at least what\u0027s supposed to be happening:\n\nSignal is triggered, and this function is called.\n\nMeanwhile, in another thread, the EnableLimitDispatchTable is in the midst of being called. The first thing that happens in that function is a call to mask this signal, then a call to atomic_exchange the value of gGlobalsMutating.\n\nIf the EnableLimitDispatchTable call wins by setting gGlobalsMutating before the signal handler does, then the signal handler will call the raise, but the signal will be masked. There is no way for the gGlobalsMutating value to have been false and then set to true without the signal having already been masked.\n\nIf you see a way that the raise can happen without the masking, please let me know. This is kind of complex, so if I\u0027ve missed something please let me know.",
      "parentUuid": "e34a50fa_dfdb5419",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c98c1ddb_482c8d23",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-14T21:26:38Z",
      "side": 1,
      "message": "So why can\u0027t you just loop and retry, rather than re-raising the signal?\n\nI now believe this works, but I think I\u0027m still missing something.\n\nIf I understand correctly, gGlobalsMutating is basically being used as a lock. It\u0027s safe to acquire in the signal handler, because you know it will never be held by the thread the handler interrupted, thus self-deadlocks cannot occur.\n\nBut you cannot use pthread_mutex_lock because that\u0027s not defined to be async-signal-safe. So you need something more primitive, based on atomics.\n\nWould it be clearer to just define a simple async-signal-safe spin-lock abstraction that assumes acquiring signal handlers are masked while the lock is held?",
      "parentUuid": "a6ccd096_94b4b8ac",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a39d40a9_58418b18",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-15T19:45:02Z",
      "side": 1,
      "message": "Yep, you are correct about everything here.\n\nThe reason I\u0027m not looping is that I\u0027m using the re-raising as a poor man\u0027s conditional and avoiding a busy loop. When re-raising the signal, it\u0027s not blocked, it\u0027s masked so the signal is still pending. As soon as the signal is no longer masked, it re-raises on its own.\n\nI didn\u0027t want to define an async-signal-safe spin lock because is the only place it\u0027s being used.\n\nI updated the comment around the raise so it\u0027s clear why I\u0027m doing what I\u0027m doing, let me know if that makes this more readable.",
      "parentUuid": "c98c1ddb_482c8d23",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96d0940f_28bf675c",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 86,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-01T02:31:59Z",
      "side": 1,
      "message": "I would consider memory_order_relaxed accesses to this. I think it\u0027s safe, and may get you some performance back. The added overhead here looks fairly substantial. If the limit is not exact, it may be possible to make this much cheaper by tracking at a much lower level, when regions are allocated.",
      "range": {
        "startLine": 86,
        "startChar": 24,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12be165d_781d2cb6",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 86,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-07T18:57:03Z",
      "side": 1,
      "message": "I changed all read access to memory_order_relaxed. I left the fetch_{add,sub} the same.",
      "parentUuid": "96d0940f_28bf675c",
      "range": {
        "startLine": 86,
        "startChar": 24,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "758cef25_1a606178",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-01T02:31:59Z",
      "side": 1,
      "message": "This can\u0027t happen concurrently with malloc calls?",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d4f3057_b6f275d0",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-07T18:57:03Z",
      "side": 1,
      "message": "Yes it can, but the malloc calls that make use of this variable only ever happen after the dispatch table below is changed in EnableLimitDispatchTable(). Since this variable is set once and always read-only, and the enabling only occurs after some locking and other atomic stores in the enable function.",
      "parentUuid": "758cef25_1a606178",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f507f5fa_8ddb187d",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-08T01:33:34Z",
      "side": 1,
      "message": "So this can\u0027t be unset? So this always happens-before any read accesses to gAllocLimit read accesses?\n\nSounds good.",
      "parentUuid": "3d4f3057_b6f275d0",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2819111c_563a54a2",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-11T22:58:21Z",
      "side": 1,
      "message": "Yes, it\u0027s only set once, it\u0027s only allowed to be set once to make this code simpler. Once a limit is enabled, that\u0027s it, you can\u0027t change it.",
      "parentUuid": "f507f5fa_8ddb187d",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}