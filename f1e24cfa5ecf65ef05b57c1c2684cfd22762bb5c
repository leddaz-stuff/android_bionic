{
  "comments": [
    {
      "key": {
        "uuid": "54615c3d_e3a7f8c3",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-01T02:31:59Z",
      "side": 1,
      "message": "Won\u0027t this resend the signal before mainline code has made any progress? Thus if you interrupted a thread holding the gGlobalsMutating \"lock\", wouldn\u0027t you immediately hit that case again?",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1bea25b_4fb96fbe",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-07T18:57:03Z",
      "side": 1,
      "message": "It should only ever resend the signal once. The code in the other thread blocks the signal, so the only way you can get to this point is if the signal is now blocked (and will resend when it\u0027s unblocked in the other thread).",
      "parentUuid": "54615c3d_e3a7f8c3",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e34a50fa_dfdb5419",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-08T01:33:34Z",
      "side": 1,
      "message": "I think I\u0027m misunderstanding something here. I concluded last time that this is called from a signal handler, and you\u0027re going through the atomic_exchange locking to make that safe in the event you interrupted ?\n\nThus my conclusion was that raising the signal here would cause the signal handler to exit and reenable the signal, at which point, the signal handler would be immediately reinvoked. I don\u0027t think the interrupted thread will have had a chance to advance at that point.\n\nWhat did I miss?",
      "parentUuid": "a1bea25b_4fb96fbe",
      "range": {
        "startLine": 136,
        "startChar": 4,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96d0940f_28bf675c",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 86,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-01T02:31:59Z",
      "side": 1,
      "message": "I would consider memory_order_relaxed accesses to this. I think it\u0027s safe, and may get you some performance back. The added overhead here looks fairly substantial. If the limit is not exact, it may be possible to make this much cheaper by tracking at a much lower level, when regions are allocated.",
      "range": {
        "startLine": 86,
        "startChar": 24,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12be165d_781d2cb6",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 86,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-07T18:57:03Z",
      "side": 1,
      "message": "I changed all read access to memory_order_relaxed. I left the fetch_{add,sub} the same.",
      "parentUuid": "96d0940f_28bf675c",
      "range": {
        "startLine": 86,
        "startChar": 24,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "758cef25_1a606178",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-01T02:31:59Z",
      "side": 1,
      "message": "This can\u0027t happen concurrently with malloc calls?",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d4f3057_b6f275d0",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-03-07T18:57:03Z",
      "side": 1,
      "message": "Yes it can, but the malloc calls that make use of this variable only ever happen after the dispatch table below is changed in EnableLimitDispatchTable(). Since this variable is set once and always read-only, and the enabling only occurs after some locking and other atomic stores in the enable function.",
      "parentUuid": "758cef25_1a606178",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f507f5fa_8ddb187d",
        "filename": "libc/bionic/malloc_limit.cpp",
        "patchSetId": 12
      },
      "lineNbr": 307,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-08T01:33:34Z",
      "side": 1,
      "message": "So this can\u0027t be unset? So this always happens-before any read accesses to gAllocLimit read accesses?\n\nSounds good.",
      "parentUuid": "3d4f3057_b6f275d0",
      "range": {
        "startLine": 307,
        "startChar": 2,
        "endLine": 307,
        "endChar": 16
      },
      "revId": "f1e24cfa5ecf65ef05b57c1c2684cfd22762bb5c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}