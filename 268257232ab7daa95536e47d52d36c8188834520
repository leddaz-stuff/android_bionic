{
  "comments": [
    {
      "key": {
        "uuid": "63f82afb_3b06d71f",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 165,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-04-08T03:37:58Z",
      "side": 1,
      "message": "suspend",
      "range": {
        "startLine": 165,
        "startChar": 33,
        "endLine": 165,
        "endChar": 37
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "63f82afb_d5bfbca2",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 165,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-04-08T18:04:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "63f82afb_3b06d71f",
      "range": {
        "startLine": 165,
        "startChar": 33,
        "endLine": 165,
        "endChar": 37
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3eea234_7d9df7b0",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 303,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-04-08T03:37:58Z",
      "side": 1,
      "message": "\"can_acquire_read_lock\"?",
      "range": {
        "startLine": 303,
        "startChar": 10,
        "endLine": 303,
        "endChar": 33
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3eea234_f7a48085",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 303,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-04-08T18:04:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a3eea234_7d9df7b0",
      "range": {
        "startLine": 303,
        "startChar": 10,
        "endLine": 303,
        "endChar": 33
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e3ec1a3e_7f8ccfcb",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 321,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-04-08T03:37:58Z",
      "side": 1,
      "message": "Not necessarily.  X86 has dedicated instructions.  ARM uses load/store exclusive.  Logically none of this really matters, but I don\u0027t understand the purpose of the parenthetical comment.",
      "range": {
        "startLine": 320,
        "startChar": 65,
        "endLine": 321,
        "endChar": 36
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "63f82afb_75d4e8e5",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 321,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-04-08T18:04:04Z",
      "side": 1,
      "message": "In my understanding, compare and exchange operations can be implemented as dedicated instructions, or load/store exclusive combination. But it may not be suitable for others, and I can\u0027t guarantee atomic_fetch_xx() operations are implemented by compare and exchange operations, although that is what I expect. So I changed the comment a little.",
      "parentUuid": "e3ec1a3e_7f8ccfcb",
      "range": {
        "startLine": 320,
        "startChar": 65,
        "endLine": 321,
        "endChar": 36
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3eea234_5d6f5b23",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 403,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-04-08T03:37:58Z",
      "side": 1,
      "message": "Maybe once is enough for the comment?",
      "range": {
        "startLine": 399,
        "startChar": 4,
        "endLine": 403,
        "endChar": 20
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3eea234_f726406b",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 403,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-04-08T18:04:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a3eea234_5d6f5b23",
      "range": {
        "startLine": 399,
        "startChar": 4,
        "endLine": 403,
        "endChar": 20
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3eea234_00c4488f",
        "filename": "libc/private/bionic_lock.h",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-04-08T03:37:58Z",
      "side": 1,
      "message": "All of these locks should almost certainly spin a few times before they sleep.  That seems especially clear here, since this lock should be held very briefly, so __futex_wait really only makes sense if the holder was suspended in the critical section, which should be very rare.  Maybe add an explicit TODO comment?",
      "range": {
        "startLine": 61,
        "startChar": 7,
        "endLine": 61,
        "endChar": 70
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "63f82afb_b59310ac",
        "filename": "libc/private/bionic_lock.h",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-04-08T18:04:04Z",
      "side": 1,
      "message": "Maybe you expect a spinlock here. But as we are not kernel, we can\u0027t prevent the thread holding the lock from being scheduled out. I am not sure it is helpful to spin a few times before going to sleep. After all, we don\u0027t know if the thread holding the lock is running in another processor, or being scheduled out. Although I guess the former is in higher possibility. I also can\u0027t find any implementation spinning a few times before going to sleep. So I am not sure if we really want to implement it. More proof?",
      "parentUuid": "a3eea234_00c4488f",
      "range": {
        "startLine": 61,
        "startChar": 7,
        "endLine": 61,
        "endChar": 70
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3eea234_896fdc22",
        "filename": "libc/private/bionic_lock.h",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-04-08T19:04:47Z",
      "side": 1,
      "message": "I think there\u0027s actually a fair amount of research literature on this, though I don\u0027t have a reference handy.  The underlying observation is simple:  Invoking the scheduler typically costs a couple of orders of magnitude more time than the hold time for these locks (maybe  several usecs vs \u003c100nsecs; I haven\u0027t measured it under realistic Android conditions).  Thus if you, say wait 10 times for 20 nsecs each before entering the kernel, you save several usecs when it succeeds, and it costs you 200 nsecs when it fails.  The success rate is very likely to be significantly \u003e 50%, so that\u0027s a large win.  This makes sense everywhere except on a uniprocessor, and we\u0027re mostly ignoring those.  I think most other implementations do something like that these days.  Windows has an explicit InitializeCriticalSectionAndSpinCount API function.\n\nFor higher-level locks, it may make sense to make the spin count adaptive:  If spinning worked in the past, spin a little longer before using a futex.\n\nI think this also applies to power-sensitive contexts like ours. Entering the kernel no doubt also costs a lot of power.",
      "parentUuid": "63f82afb_b59310ac",
      "range": {
        "startLine": 61,
        "startChar": 7,
        "endLine": 61,
        "endChar": 70
      },
      "revId": "268257232ab7daa95536e47d52d36c8188834520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}