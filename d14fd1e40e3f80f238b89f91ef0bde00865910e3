{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4b4597b0_8166fd6c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-16T11:34:04Z",
      "side": 1,
      "message": "First pass - looking at the whole thing. Probably enough to keep you busy.",
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ff7ef1e_94eb60ea",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-16T11:34:04Z",
      "side": 1,
      "message": "The \"8\" should be in a constant somewhere. That constant should be _very_ well documented in the code, and duped as little as possible (which could be hard in this case, though \"8\" could possibly be a build def / #define supplied by the build if you felt strongly about keeping it to one).\n\nThe docs will need to communicate what it means and why it should change.\n\nAlso, there will need to be changes to any docs that describe what to do when:\n(a) updating bionic\u0027s tzcode,\n(b) when incrementing or removing support for a tz format version from the apex (depending on whether this should track the latest or the oldest format)\n\nThings that should be mentioned in the docs:\n\n1) What \"8\" represents. i.e. it refers to the \"format version\" of the TZ data files to use in the tzdata apex. Given the apex will start to contain multiple versions of files, bionic needs to know which one to use.\n2) When it should be changed. e.g. if this is tied to a constant elsewhere in Android, then maybe link to that (or (3) should probably be preferred)\n3) Probably a link to a README.md in system/timezone that can serve as documentation around format version and what it is. There are some docs already, but they should be updated because the apex is changing.",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0111fff_5793660c",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-16T16:46:33Z",
      "side": 1,
      "message": "i think we need a comment here to make it clear why you\u0027re hard-coding a version at all. i think it\u0027s because you want static binaries to find the version of tzdata that corresponds to their version of tzcode? (as i\u0027ve said before, i\u0027m not sure how much i/we care about that use case. static binaries are only sort-of supported as it is.)",
      "parentUuid": "3ff7ef1e_94eb60ea",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c20a8b37_4e2cb1a8",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-17T14:58:53Z",
      "side": 1,
      "message": "\u003e The docs will need to communicate what it means and why it should change.\n\nAgree. I wanted to land code changes first to update prebuilts faster and remove obsolete code (like reading from etc/tz/tzdata).\n\n\u003e i think it\u0027s because you want static binaries to find the version of tzdata that corresponds to their version of tzcode\n\nNope, reasoning is different and where probably disagree. There were no issues with tzcode reading TZif files, but I think it\u0027s safer to read TZif files generated from the same checkout even if there is RFC.",
      "parentUuid": "b0111fff_5793660c",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "162901e4_64571c40",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-21T12:18:49Z",
      "side": 1,
      "message": "Marking as resolved.",
      "parentUuid": "c20a8b37_4e2cb1a8",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72134417_4b060e83",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-16T11:34:04Z",
      "side": 1,
      "message": "Do we need to keep this? Why? I thought we were replacing this. i.e. I can think of a situation where /apex/com.android.tzdata isn\u0027t available and bionic needs to work - e.g. apexd hasn\u0027t run yet to mount the apex, but I can\u0027t think of a world where we\u0027d have /etc/tz/tzdata but not /versioned.\n\nIn fact, if somebody in a few years were to drop 8 support and this constant hadn\u0027t been maintained, leaving this code would potentially _hide_ the fact somebody has forgotten to update the constant. That said, with the fallback to /system, that will already happen, unfortunately.\n\nShould it be release flagged?",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e1e154e_64bd3f3c",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-16T16:46:33Z",
      "side": 1,
      "message": "should we drop the /system one?",
      "parentUuid": "72134417_4b060e83",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92f3366c_663e4d90",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-17T14:58:53Z",
      "side": 1,
      "message": "I left it just in case if there are configurations which will include this topic in system image, but use old tzdata prebuilt. Once prebuilts are updated, I will remove this path check.\n\n\u003e should we drop the /system one?\n\nProbably not in this CL :) Is it safe in general?",
      "parentUuid": "72134417_4b060e83",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d023d36_efad7b9d",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-17T16:32:45Z",
      "side": 1,
      "message": "i don\u0027t know ... probably for static libc purposes we need to keep \"all the places it\u0027s ever been\". which is one of the main reasons why i\u0027m not as worried about [deliberate] breaking changes as you are --- i just don\u0027t think they\u0027re really practical for any OS. (if you look at tzfile \"versions\" 3 and 4, for example, they\u0027re really just clarifying the interpretation of existing data.)",
      "parentUuid": "92f3366c_663e4d90",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcf07250_49ac0feb",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-17T16:52:44Z",
      "side": 1,
      "message": "Can it affect anything from Android-only perspective? Nothing cares about time zones before /apex is mounted, right?",
      "parentUuid": "1d023d36_efad7b9d",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c47a6ba3_274d6599",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-17T19:19:48Z",
      "side": 1,
      "message": "my point was that if you _build_ a static binary with this version of libc, it might _run_ on an older system. this doesn\u0027t usually matter for _dynamic_ linking because you\u0027ll be using the libc that corresponds to the device (and if that\u0027s broken, well, you\u0027re screwed anyway and may as well give up). but the theory with static linking is \"one binary works everywhere\". which is why developers like it, and infrastructure maintainers hate it (because that\u0027s a really hard promise to keep, and who\u0027s doing all the testing anyway?).\n\nthere\u0027s a larger question of \"to what extent are static binaries really supported, beyond init and vold on the system [which is _effectively_ the same as the dynamic case, so easier]?\", but -- unlike Apple who say \"fuck no\", and glibc who have a sort of passive-aggressive \"we\u0027ll complain loudly but we won\u0027t actually stop you\" -- we haven\u0027t really taken a stance. (which effectively means \"we support this\".)\n\nTL;DR: unless you\u0027re _looking_ for battles to fight (which isn\u0027t as insane as it might seem --- there can be value to \"dealing with all the pain in one go\"), and your mono/golang/absl comments make me think you\u0027re very much _not_ looking to move anyone off what they\u0027re already doing, then i think \"leave the existing options, just add your new thing in front of them, and add \u0027static binaries\u0027 to your list of things to test\".",
      "parentUuid": "fcf07250_49ac0feb",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88849e69_7f40f623",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-21T12:18:49Z",
      "side": 1,
      "message": "Mono is when I started to think about fixing this situation: in mono / dotnet they are falling back to TZif v1 if they encounter unsupported TZif (i.e. not v1 or v2 or v3) and do not throw exception [1]. They don\u0027t even log anything.\n\nSo I want to fix this because I do not want to be responsible for bugs in 3p code and spend time finding root cause.\n\n[1] https://github.com/dotnet/runtime/issues/93216#issuecomment-1753412998",
      "parentUuid": "c47a6ba3_274d6599",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8afaae27_9bbb3dea",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-21T16:34:10Z",
      "side": 1,
      "message": "Question for enh@\n\nFor the static NDK use case, I thought (perhaps incorrectly) that the version of bionic was very old and may pre-date apex completely.\n\nIs there the possibility of encountering a statically linked binary with a version of bionic after the APEX was introduced?\n\n-------\n\nGeneral comment:\n\nI think we\u0027re mostly digging into the case of \"{static binary built with bionic from Q-U} + {apex will be mounted} + {tz calcs must work and the system image tzdata file isn\u0027t good enough}\". I don\u0027t know how common that is but it feel niche. \n\nI don\u0027t mind either way, and I will always defer to enh@ when it comes to bionic. My general bias is always that less code is good and if this code stays then somebody in future will also try to keep it because they\u0027ll be even less able to reason about \"is this safe to remove?\"",
      "parentUuid": "88849e69_7f40f623",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5804b1ec_bcf241a2",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-22T19:04:26Z",
      "side": 1,
      "message": "\u003e For the static NDK use case, I thought (perhaps incorrectly) that the version of bionic was very old and may pre-date apex completely.\n\nwell, the problem is -- as the name suggests -- that the version is statically determined by the NDK you build with. so if you build a static binary with NDK r14 and run it on api level 35, you\u0027re running api level 21 (or whatever; i didn\u0027t actually look that up) libc code. whereas if you build with NDK r27 and run on api level 21, you\u0027re doing the opposite. which is why i\u0027m thinking about forwards and backwards compatibility.\n\n\u003e Is there the possibility of encountering a statically linked binary with a version of bionic after the APEX was introduced?\n\nyes. (and also from before.)\n\nand this isn\u0027t just us --- glibc has this too. (Apple doesn\u0027t; while glibc _grumbles_ about static linking, Apple just doesn\u0027t let you do it.) that\u0027s why i think upstream would see incompatible changes as a bug to be fixed. i think you\u0027ve been scared by the way icu controls both sides [code and data] and expects them to be distributed together into worrying too much about libc.\n\n-*-\n\ni think this cl as-is expresses your desired intent of \"we know how to use apex version 8 if it\u0027s available, but we\u0027re also compatible with the pre-versioned apex data, and we\u0027re even compatible with the pre-apex data\".\n\ni think my main comment would mainly be \"explicitly say that you\u0027re hard-coding 8 on purpose because \u00278\u0027 corresponds to the specific version of tzdata that the current tzcode understands\"? (this is also why i think it\u0027s mad to even consider incrementing the version number for _compatible_ changes. and that in turn is why i\u0027m skeptical that we\u0027ll actually need to deal with real incompatibility.)\n\nand \"are we sure we want to start at 8?\". i\u0027d argue that this is the _first_ versioned version :-)",
      "parentUuid": "8afaae27_9bbb3dea",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfff85e2_3e4a85da",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-22T19:16:16Z",
      "side": 1,
      "message": "There are tz_version files [1, 2] and we are just reusing its major number here. It was introduced in O-MR1 and bumped each SDK Level update (expect SC -\u003e SC v2 because neither ICU nor tzcode-s were updated).\n\nI added some information to a README file in aosp/3088745. Should I extend it and / or write more information here?\n\n[1] https://android.googlesource.com/platform/system/timezone/+/refs/heads/main/output_data/version/tz_version\n\n[2] https://android.googlesource.com/platform/system/timezone/+/refs/heads/android14-dev/output_data/version/tz_version",
      "parentUuid": "5804b1ec_bcf241a2",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8a8d4be_6c47f824",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-22T19:21:41Z",
      "side": 1,
      "message": "oh, so the version number is really the _icu_ version number, and the tzdata just happens to be stuck with the same number? that\u0027s unfortunate...",
      "parentUuid": "dfff85e2_3e4a85da",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10b67144_075f8f55",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-23T15:46:13Z",
      "side": 1,
      "message": "RE \"ICU version number\": Not quite, it\u0027s a \"tz data set version number\" as currently doc\u0027d in external/icu/android_icu4j/libcore_bridge/src/java/com/android/i18n/timezone/TzDataSetVersion.java and https://cs.android.com/android/platform/superproject/main/+/main:system/timezone/README.android;l\u003d94\n\n(Though it will need to be updated a bit after these changes)\n\nThis versioning system was originally developed for the first tz update system (APK), then carried over to APEX, and it now that version system forms the basis for the path in the new multi-version APEX - i.e. so the code looks for the version it needs out of several now available.\n\nBecause it\u0027s a single version number that covers the file _set_, Android increments the version by one any time something is changed that is likely to / actually affects the format of any of the files inside the set in a non-backwards compatible way.\n\nThe most obvious reason to do that would be when updating ICU, and when that happens Almaz will need to update the value for all things that read files from the apex.  It only needs to be incremented once per Android release - e.g. if tzcode _and_ ICU were updated within one release, that\u0027s still only one increment. As Almaz mentioned, it\u0027s not tied to Android API level deliberately because there have been API bumps which didn\u0027t involve any tz data format changes.\n\nInstead, there could be separate version numbers for different files within the set, but it would get more complicated for (for example) libs that read multiple files. Almaz is also preserving the old paths which will continue to point to a consistent set of files - the latest version.\n\nI don\u0027t think there\u0027s a lot of cost in having a version number in the path that is incremented for bionic more often than strictly necessary.\n\nFrom a system health PoV, Almaz has been experimenting and having the same file under multiple paths appears to be handled by the .img format without increasing the space too much. Block-level compression, I assume. I\u0027ve also suggested he look at hard linking to have the same file content under multiple paths/names if that turns out not to be the case or it stops working.\n\nThere are several ways to slice this - this certainly isn\u0027t the only way, but I _think_ it\u0027ll work.",
      "parentUuid": "b8a8d4be_6c47f824",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5da2e45f_91b75381",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-23T20:17:30Z",
      "side": 1,
      "message": "\u003e I don\u0027t think there\u0027s a lot of cost in having a version number in the path that is incremented for bionic more often than strictly necessary.\n\nbut it won\u0027t be incremented, right? you\u0027ll end up checking \"12 else if 11 else if 10 else if 9 else if 8 else if apex else if /system\"?\n\nif on the other hand you really do just mean \"\u003ccurrent number\u003e else if apex else if /system\", that doesn\u0027t seem like it adds any value over just having the symlink and bionic always goes straight to that. (in fact, it adds _negative_ value because you\u0027re increasing maintenance costs and runtime costs _and_ making static binaries work less well, to get at best the same effect you could have had with less effort/code.)",
      "parentUuid": "10b67144_075f8f55",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb2da855_5a1e6504",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-24T10:45:37Z",
      "side": 1,
      "message": "It will be only incremented. An APEX shipped to a device which checks for `versioned/N` will always have `versioned/N` directory. `versioned/N` will be removed only when we drop mainline support of a corresponding Android release.\n\n\u003e  that doesn\u0027t seem like it adds any value over just having the symlink and bionic always goes straight to that\n\nWe are preserving what we already have in the current tzdata module per release setup: tzcode reading TZif files and tzcode generating these files are roughly the same. \n\nWhat symlink do mean?",
      "parentUuid": "5da2e45f_91b75381",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b80c7086_2e43e4dd",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-24T11:42:29Z",
      "side": 1,
      "message": "\u003e It will be only incremented. An APEX shipped to a device which checks for versioned/N will always have versioned/N directory. versioned/N will be removed only when we drop mainline support of a corresponding Android release.\n\nbut that makes no sense for static binaries.\n\n(and at that point, i don\u0027t understand why we don\u0027t just continue to use a symlink.)\n\n\u003e What symlink do mean?\n\netc/tz/tzdata, without a version.",
      "parentUuid": "bb2da855_5a1e6504",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1323c8da_157dff8e",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-24T12:11:42Z",
      "side": 1,
      "message": "If it was built reading `versioned/N` and file is there, it will read it. If the path does not exist, `etc/tz/tzdata` will be read, just like now.\n\n\u003e (and at that point, i don\u0027t understand why we don\u0027t just continue to use a symlink.)\n\nWe want different releases to read from different paths (and possibly different files).",
      "parentUuid": "b80c7086_2e43e4dd",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bee6c4d_e6b62947",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-24T13:11:27Z",
      "side": 1,
      "message": "\u003e but it won\u0027t be incremented, right? you\u0027ll end up checking \"12 else if 11 else if 10 else if 9 else if 8 else if apex else if /system\"?\n\nThere\u0027s no proposal to do this number of fallbacks. The logic will check one versioned path - the one that matches the code. \n\nDynamic case: We expect it to find the version that matches the code.\n\ninitd/vold -type case: There\u0027s no apex, it will just have to find what it\u0027s looking for in the /system path (like today)\n\nStatic NDK case: we acknowledge that we\u0027re into edge cases. It will look for the versioned path that matches the age of the code. If it\u0027s running on a device within a certain release window, let\u0027s say it\u0027s looking for version 20, and the tzdata module on device has the paths for version 17 to version 24, it finds what it\u0027s looking for because that\u0027s inside the support window.\n\nIf it\u0027s outside of that window, e.g. it\u0027s looking for version 20 and the tzdata apex only has versions 21-28 in it, it won\u0027t find what it\u0027s looking for under a versioned path (because that path won\u0027t exist), it will do the fallback look under the unversioned path, which will be a symlink to _a_ version, I\u0027ve suggested the unversioned symlink should link to the latest version, in this example version 28. That means that the static bionic will read the latest tzdata and so there will be the biggest gap between code age (v20) and format age (v28), even though that static version of bionic is most likely to be compatible with v21 given the smaller age gap. This forces issues early, but while there\u0027s the most time to do something about it, e.g. v21 is still there to be used, but they have to update their binary (better waiting to a time when potentially there\u0027s no compatible file in the apex at all, as would happen if the symlink always pointed to the _oldest_ version in the apex).\n\nIf we find a problem - i.e. if choosing to make the symlink point to the newest version flushed out a ton of issues with static binaries to the point where it was unacceptable to go ahead, then we could keep the old version or have the symlink point to {not the latest version} while we work it out - e.g. keep it pointing to v27 for a year. People who have static binaries and are still maintaining them can rebuild them and point them at a specific version, e.g. v21, if that works for them, or update to a newer version of static bionic containing a newer version of tzcode (maybe).\n\nThe static NDK case also fairly closely mirrors the 3rd party library case - e.g. mono, rust, etc. libs that are using the unversioned path today.\n\nIf they like, they can change to point to a versioned path - they\u0027ll periodically have to update the path and make any changes to their code, but it\u0027ll be relatively stable, better than today. The case with libs like mono / rust is that they\u0027re often able to just \"rebuild your app with the latest version our lib and re-release\".\n\nIf they want to continue using the unversioned path, they can - nothing really changes Vs today - they\u0027ll just randomly break on new devices if the semantics of the file have changed.\n\nIf they want to continue supporting a wide range of devices (outside of the 7 years we are now committing to) they can also check for the existence of paths - e.g. if path /20/ exists, use impl A code, else if path /8/ exists, use impl B code, etc.",
      "parentUuid": "1323c8da_157dff8e",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5460133c_5c9743e0",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-28T19:40:15Z",
      "side": 1,
      "message": "the more both of you talk about this, the less i think this makes sense.\n\nfor me the static binary problem is a reason why i don\u0027t expect breaking changes (and a reason why i don\u0027t want to change paths unless absolutely necessary). and i don\u0027t think there\u0027s any benefit _or_ need right now?\n\nand i think the golang/mono argument shows you think the same --- if we wouldn\u0027t break golang/mono, we _certainly_ wouldn\u0027t break c/c++/rust...\n\ni think just sticking with the existing symlink for now is the right choice. there\u0027s no advantage to requiring a path with a version number in it until/unless we actually have a breaking change.",
      "parentUuid": "4bee6c4d_e6b62947",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51c12862_84e4e360",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-29T16:46:24Z",
      "side": 1,
      "message": "\u003e and i think the golang/mono argument shows you think the same --- if we wouldn\u0027t break golang/mono, we certainly wouldn\u0027t break c/c++/rust...\n\nI don\u0027t really care _that_ much about golang/mono/\u003cwhatever-non-platform-code\u003e: if they fail to read a valid TZif entry within tzdata file that\u0027s their problem.\n\n\u003e until/unless we actually have a breaking change\n\nThat\u0027s one of the reasons why we introduce versioning: it allows for each release to read its specific version of tzdata. Currently that\u0027s achieved it by having release specific tzdata (tzdata5 for U, tzdata4 for T and so on). But that won\u0027t work if we ship the same APEX to a range of Android releases.",
      "parentUuid": "5460133c_5c9743e0",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b76863ea_58891a65",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-30T20:57:34Z",
      "side": 1,
      "message": "but you don\u0027t need to check the versioned path yet, and you _do_ need to keep the symlink, so i just don\u0027t think this makes any sense until/unless we actually do have a breaking change. (which, as i keep saying, i honestly don\u0027t believe will happen. and even if it does happen, i still struggle to believe that the solution wouldn\u0027t be \"revert that\"!)",
      "parentUuid": "51c12862_84e4e360",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}