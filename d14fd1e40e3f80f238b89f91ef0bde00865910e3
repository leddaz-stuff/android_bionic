{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4b4597b0_8166fd6c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-16T11:34:04Z",
      "side": 1,
      "message": "First pass - looking at the whole thing. Probably enough to keep you busy.",
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ff7ef1e_94eb60ea",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-16T11:34:04Z",
      "side": 1,
      "message": "The \"8\" should be in a constant somewhere. That constant should be _very_ well documented in the code, and duped as little as possible (which could be hard in this case, though \"8\" could possibly be a build def / #define supplied by the build if you felt strongly about keeping it to one).\n\nThe docs will need to communicate what it means and why it should change.\n\nAlso, there will need to be changes to any docs that describe what to do when:\n(a) updating bionic\u0027s tzcode,\n(b) when incrementing or removing support for a tz format version from the apex (depending on whether this should track the latest or the oldest format)\n\nThings that should be mentioned in the docs:\n\n1) What \"8\" represents. i.e. it refers to the \"format version\" of the TZ data files to use in the tzdata apex. Given the apex will start to contain multiple versions of files, bionic needs to know which one to use.\n2) When it should be changed. e.g. if this is tied to a constant elsewhere in Android, then maybe link to that (or (3) should probably be preferred)\n3) Probably a link to a README.md in system/timezone that can serve as documentation around format version and what it is. There are some docs already, but they should be updated because the apex is changing.",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0111fff_5793660c",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-16T16:46:33Z",
      "side": 1,
      "message": "i think we need a comment here to make it clear why you\u0027re hard-coding a version at all. i think it\u0027s because you want static binaries to find the version of tzdata that corresponds to their version of tzcode? (as i\u0027ve said before, i\u0027m not sure how much i/we care about that use case. static binaries are only sort-of supported as it is.)",
      "parentUuid": "3ff7ef1e_94eb60ea",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c20a8b37_4e2cb1a8",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-17T14:58:53Z",
      "side": 1,
      "message": "\u003e The docs will need to communicate what it means and why it should change.\n\nAgree. I wanted to land code changes first to update prebuilts faster and remove obsolete code (like reading from etc/tz/tzdata).\n\n\u003e i think it\u0027s because you want static binaries to find the version of tzdata that corresponds to their version of tzcode\n\nNope, reasoning is different and where probably disagree. There were no issues with tzcode reading TZif files, but I think it\u0027s safer to read TZif files generated from the same checkout even if there is RFC.",
      "parentUuid": "b0111fff_5793660c",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "162901e4_64571c40",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 248,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-21T12:18:49Z",
      "side": 1,
      "message": "Marking as resolved.",
      "parentUuid": "c20a8b37_4e2cb1a8",
      "range": {
        "startLine": 248,
        "startChar": 76,
        "endLine": 248,
        "endChar": 77
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72134417_4b060e83",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-16T11:34:04Z",
      "side": 1,
      "message": "Do we need to keep this? Why? I thought we were replacing this. i.e. I can think of a situation where /apex/com.android.tzdata isn\u0027t available and bionic needs to work - e.g. apexd hasn\u0027t run yet to mount the apex, but I can\u0027t think of a world where we\u0027d have /etc/tz/tzdata but not /versioned.\n\nIn fact, if somebody in a few years were to drop 8 support and this constant hadn\u0027t been maintained, leaving this code would potentially _hide_ the fact somebody has forgotten to update the constant. That said, with the fallback to /system, that will already happen, unfortunately.\n\nShould it be release flagged?",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e1e154e_64bd3f3c",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-16T16:46:33Z",
      "side": 1,
      "message": "should we drop the /system one?",
      "parentUuid": "72134417_4b060e83",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92f3366c_663e4d90",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-17T14:58:53Z",
      "side": 1,
      "message": "I left it just in case if there are configurations which will include this topic in system image, but use old tzdata prebuilt. Once prebuilts are updated, I will remove this path check.\n\n\u003e should we drop the /system one?\n\nProbably not in this CL :) Is it safe in general?",
      "parentUuid": "72134417_4b060e83",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d023d36_efad7b9d",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-17T16:32:45Z",
      "side": 1,
      "message": "i don\u0027t know ... probably for static libc purposes we need to keep \"all the places it\u0027s ever been\". which is one of the main reasons why i\u0027m not as worried about [deliberate] breaking changes as you are --- i just don\u0027t think they\u0027re really practical for any OS. (if you look at tzfile \"versions\" 3 and 4, for example, they\u0027re really just clarifying the interpretation of existing data.)",
      "parentUuid": "92f3366c_663e4d90",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcf07250_49ac0feb",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-17T16:52:44Z",
      "side": 1,
      "message": "Can it affect anything from Android-only perspective? Nothing cares about time zones before /apex is mounted, right?",
      "parentUuid": "1d023d36_efad7b9d",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c47a6ba3_274d6599",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-17T19:19:48Z",
      "side": 1,
      "message": "my point was that if you _build_ a static binary with this version of libc, it might _run_ on an older system. this doesn\u0027t usually matter for _dynamic_ linking because you\u0027ll be using the libc that corresponds to the device (and if that\u0027s broken, well, you\u0027re screwed anyway and may as well give up). but the theory with static linking is \"one binary works everywhere\". which is why developers like it, and infrastructure maintainers hate it (because that\u0027s a really hard promise to keep, and who\u0027s doing all the testing anyway?).\n\nthere\u0027s a larger question of \"to what extent are static binaries really supported, beyond init and vold on the system [which is _effectively_ the same as the dynamic case, so easier]?\", but -- unlike Apple who say \"fuck no\", and glibc who have a sort of passive-aggressive \"we\u0027ll complain loudly but we won\u0027t actually stop you\" -- we haven\u0027t really taken a stance. (which effectively means \"we support this\".)\n\nTL;DR: unless you\u0027re _looking_ for battles to fight (which isn\u0027t as insane as it might seem --- there can be value to \"dealing with all the pain in one go\"), and your mono/golang/absl comments make me think you\u0027re very much _not_ looking to move anyone off what they\u0027re already doing, then i think \"leave the existing options, just add your new thing in front of them, and add \u0027static binaries\u0027 to your list of things to test\".",
      "parentUuid": "fcf07250_49ac0feb",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88849e69_7f40f623",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-21T12:18:49Z",
      "side": 1,
      "message": "Mono is when I started to think about fixing this situation: in mono / dotnet they are falling back to TZif v1 if they encounter unsupported TZif (i.e. not v1 or v2 or v3) and do not throw exception [1]. They don\u0027t even log anything.\n\nSo I want to fix this because I do not want to be responsible for bugs in 3p code and spend time finding root cause.\n\n[1] https://github.com/dotnet/runtime/issues/93216#issuecomment-1753412998",
      "parentUuid": "c47a6ba3_274d6599",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8afaae27_9bbb3dea",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-21T16:34:10Z",
      "side": 1,
      "message": "Question for enh@\n\nFor the static NDK use case, I thought (perhaps incorrectly) that the version of bionic was very old and may pre-date apex completely.\n\nIs there the possibility of encountering a statically linked binary with a version of bionic after the APEX was introduced?\n\n-------\n\nGeneral comment:\n\nI think we\u0027re mostly digging into the case of \"{static binary built with bionic from Q-U} + {apex will be mounted} + {tz calcs must work and the system image tzdata file isn\u0027t good enough}\". I don\u0027t know how common that is but it feel niche. \n\nI don\u0027t mind either way, and I will always defer to enh@ when it comes to bionic. My general bias is always that less code is good and if this code stays then somebody in future will also try to keep it because they\u0027ll be even less able to reason about \"is this safe to remove?\"",
      "parentUuid": "88849e69_7f40f623",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5804b1ec_bcf241a2",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-22T19:04:26Z",
      "side": 1,
      "message": "\u003e For the static NDK use case, I thought (perhaps incorrectly) that the version of bionic was very old and may pre-date apex completely.\n\nwell, the problem is -- as the name suggests -- that the version is statically determined by the NDK you build with. so if you build a static binary with NDK r14 and run it on api level 35, you\u0027re running api level 21 (or whatever; i didn\u0027t actually look that up) libc code. whereas if you build with NDK r27 and run on api level 21, you\u0027re doing the opposite. which is why i\u0027m thinking about forwards and backwards compatibility.\n\n\u003e Is there the possibility of encountering a statically linked binary with a version of bionic after the APEX was introduced?\n\nyes. (and also from before.)\n\nand this isn\u0027t just us --- glibc has this too. (Apple doesn\u0027t; while glibc _grumbles_ about static linking, Apple just doesn\u0027t let you do it.) that\u0027s why i think upstream would see incompatible changes as a bug to be fixed. i think you\u0027ve been scared by the way icu controls both sides [code and data] and expects them to be distributed together into worrying too much about libc.\n\n-*-\n\ni think this cl as-is expresses your desired intent of \"we know how to use apex version 8 if it\u0027s available, but we\u0027re also compatible with the pre-versioned apex data, and we\u0027re even compatible with the pre-apex data\".\n\ni think my main comment would mainly be \"explicitly say that you\u0027re hard-coding 8 on purpose because \u00278\u0027 corresponds to the specific version of tzdata that the current tzcode understands\"? (this is also why i think it\u0027s mad to even consider incrementing the version number for _compatible_ changes. and that in turn is why i\u0027m skeptical that we\u0027ll actually need to deal with real incompatibility.)\n\nand \"are we sure we want to start at 8?\". i\u0027d argue that this is the _first_ versioned version :-)",
      "parentUuid": "8afaae27_9bbb3dea",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfff85e2_3e4a85da",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1793992
      },
      "writtenOn": "2024-05-22T19:16:16Z",
      "side": 1,
      "message": "There are tz_version files [1, 2] and we are just reusing its major number here. It was introduced in O-MR1 and bumped each SDK Level update (expect SC -\u003e SC v2 because neither ICU nor tzcode-s were updated).\n\nI added some information to a README file in aosp/3088745. Should I extend it and / or write more information here?\n\n[1] https://android.googlesource.com/platform/system/timezone/+/refs/heads/main/output_data/version/tz_version\n\n[2] https://android.googlesource.com/platform/system/timezone/+/refs/heads/android14-dev/output_data/version/tz_version",
      "parentUuid": "5804b1ec_bcf241a2",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8a8d4be_6c47f824",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-05-22T19:21:41Z",
      "side": 1,
      "message": "oh, so the version number is really the _icu_ version number, and the tzdata just happens to be stuck with the same number? that\u0027s unfortunate...",
      "parentUuid": "dfff85e2_3e4a85da",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10b67144_075f8f55",
        "filename": "libc/tzcode/bionic.cpp",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 1038039
      },
      "writtenOn": "2024-05-23T15:46:13Z",
      "side": 1,
      "message": "RE \"ICU version number\": Not quite, it\u0027s a \"tz data set version number\" as currently doc\u0027d in external/icu/android_icu4j/libcore_bridge/src/java/com/android/i18n/timezone/TzDataSetVersion.java and https://cs.android.com/android/platform/superproject/main/+/main:system/timezone/README.android;l\u003d94\n\n(Though it will need to be updated a bit after these changes)\n\nThis versioning system was originally developed for the first tz update system (APK), then carried over to APEX, and it now that version system forms the basis for the path in the new multi-version APEX - i.e. so the code looks for the version it needs out of several now available.\n\nBecause it\u0027s a single version number that covers the file _set_, Android increments the version by one any time something is changed that is likely to / actually affects the format of any of the files inside the set in a non-backwards compatible way.\n\nThe most obvious reason to do that would be when updating ICU, and when that happens Almaz will need to update the value for all things that read files from the apex.  It only needs to be incremented once per Android release - e.g. if tzcode _and_ ICU were updated within one release, that\u0027s still only one increment. As Almaz mentioned, it\u0027s not tied to Android API level deliberately because there have been API bumps which didn\u0027t involve any tz data format changes.\n\nInstead, there could be separate version numbers for different files within the set, but it would get more complicated for (for example) libs that read multiple files. Almaz is also preserving the old paths which will continue to point to a consistent set of files - the latest version.\n\nI don\u0027t think there\u0027s a lot of cost in having a version number in the path that is incremented for bionic more often than strictly necessary.\n\nFrom a system health PoV, Almaz has been experimenting and having the same file under multiple paths appears to be handled by the .img format without increasing the space too much. Block-level compression, I assume. I\u0027ve also suggested he look at hard linking to have the same file content under multiple paths/names if that turns out not to be the case or it stops working.\n\nThere are several ways to slice this - this certainly isn\u0027t the only way, but I _think_ it\u0027ll work.",
      "parentUuid": "b8a8d4be_6c47f824",
      "range": {
        "startLine": 252,
        "startChar": 52,
        "endLine": 252,
        "endChar": 58
      },
      "revId": "d14fd1e40e3f80f238b89f91ef0bde00865910e3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}