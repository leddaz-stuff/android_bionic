{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3f919c74_f4b95a50",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1892347
      },
      "writtenOn": "2023-02-28T14:25:35Z",
      "side": 1,
      "message": "I don\u0027t think you would normally put a panic handler in a library like this one, since the panic handler must be unique for the entire application, so if something else also uses Rust, now you have two (libc\u0027s and the one from the Rust standard library).\n\nYou say you didn\u0027t run into issues with a panic handler in the previous commit â€” my guess is that this is because that commit can never panic, so the handler might have been dead-code-eliminated.\n\nIn general, since the final executable needs a panic handler, I suspect you need some way to have one linked in when nobody uses the Rust standard library (it should just abort the program), and to not link it in when the standard library is available, since std provides its own panic handler.",
      "revId": "a95fab184544b25edaee129171552ee7eb931cb3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f01906fe_b8a35b62",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2023-02-28T23:37:13Z",
      "side": 1,
      "message": "DCE probably explains it, good point.\n\nI wonder what the solution here would be. I don\u0027t know enough about how `#[panic_handler]` works to know if this makes sense, but the way I\u0027d handle something like this in C/C++ would be with a weak symbol to solve the issue for static executables, and dynamic executables end up leaning on loader resolution behavior (that\u0027s how overridable new/delete work in C++).\n\nDepending on how important it is for a rust executable to have one and only one panic handler, it could potentially be dealt with the way that libc currently deals with new and delete: it\u0027s a private symbol that\u0027s not visible to anything linking against libc.so (and a weak symbol is used for libc.a users).\n\nThis isn\u0027t urgent, FWIW. Just trying to prove if this would be an option for making libc safer in the future.",
      "parentUuid": "3f919c74_f4b95a50",
      "revId": "a95fab184544b25edaee129171552ee7eb931cb3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}