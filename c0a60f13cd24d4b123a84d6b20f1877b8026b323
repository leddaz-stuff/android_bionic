{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7f28c76b_3112497b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-15T01:58:01Z",
      "side": 1,
      "message": "We ran into this at Meta while testing bpftrace compiled against libbpf 1.2.2 (from ExtendedAndroidTools [1]), which failed to load BTF data on account of calling faccessat() with AT_EACCESS [2]. I suspect similar issues may arise once Android updates external/libbpf to a newer version.\n\nHaving limited support for AT_EACCESS (i.e. allowing it only when it doesn\u0027t actually need to do anything) isn\u0027t ideal. However, given the comment about Android not running code with euid!\u003duid, I figured it may be better to not error out (and break user code) in the case that _is_ supported.\n\nAn alternative would be to fix all users of AT_EACCESS to first check if libc supports it, but that may be impractical.\n\n[1] https://github.com/facebookexperimental/ExtendedAndroidTools\n[2] https://github.com/libbpf/libbpf/blob/0c54691bae75cdf50c43be3ff5ac3b201fc94ba2/src/btf.c#L4951",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6186034_7ee1b441",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-15T16:15:38Z",
      "side": 1,
      "message": "if we\u0027re going to allow AT_EACCESS, it might make more sense to revisit this decision instead?",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59937ea6_baa2eac3",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-15T16:55:51Z",
      "side": 1,
      "message": "Since there\u0027s still a number of devices running older kernels, I think we\u0027d also need to have a fallback path that allows `AT_EACCESS` without using `faccessat2()`.\n\nI was hesitant to make the code more complicated given that AFAIK we don\u0027t have a use case that would require _fully_ supporting these flags (rather than just the `uid\u003d\u003deuid` case, where `AT_EACCESS` can be ignored), but happy to revisit if you think that\u0027d be cleaner.",
      "parentUuid": "c6186034_7ee1b441",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dc446e5_97d73db1",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-15T20:37:58Z",
      "side": 1,
      "message": "\u003e Since there\u0027s still a number of devices running older kernels, I think we\u0027d also need to have a fallback path that allows AT_EACCESS without using faccessat2().\n\nwe\u0027ll only use faccessat2() in apps on devices running \u003e\u003d V, and they can\u0027t ship with kernels older than 5.8.\n\n_static_ binaries will be affected, but they\u0027re only ever quasi-supported anyway. lots of stuff doesn\u0027t work there. we certainly have no precedent for checking the kernel version to choose a syscall, and you can\u0027t \"fall back\" on Android like you would in other libcs because you\u0027re already dead from the SIGSYS you got from trying a syscall that\u0027s not in the seccomp filter.\n\n\u003e I was hesitant to make the code more complicated\n\ndefine \"complicated\". i think _you_ mean \"more complicated to test\", whereas i mean \"fewer lines of source and fewer special cases\" :-)\n\n(given that we support AT_SYMLINK_NOFOLLOW elsewhere, i was assuming we\u0027d just let faccessat2()/seccomp/selinux policy decide that --- if someone really wants to block it, they should do it properly. in the meantime, i see there\u0027s another new flag in the kernel that hasn\u0027t made it to the man page yet, which seems like another argument for \"yeah, let\u0027s do this properly now\".)\n\nbtw, only do this if it sounds like fun --- if you\u0027re thinking \"well, okay, but that\u0027s more than i was signing up for\", just say and i\u0027ll make those changes for you. (it\u0027s mildly intricate if you haven\u0027t done it before, but grepping for `__faccessat` should let you copy \u0026 paste your way through. that\u0027s certainly what i\u0027d do if it were me :-) )",
      "parentUuid": "59937ea6_baa2eac3",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "732ebccc_a755063d",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-15T22:16:01Z",
      "side": 1,
      "message": "Appreciate your feedback @enh@google.com!\n\n\u003e i think you mean \"more complicated to test\", whereas i mean \"fewer lines of source and fewer special cases\" :-)\n\nI was under the assumption that we\u0027d need to support kernels that don\u0027t have `faccessat2()`, so by \"more complicated\" I meant a bunch of extra code (a way to detect if the syscall exists, plus the same fallback path as currently implemented that checks if euid matches uid etc.) to support a flag that we may not have a use for (yet?)\n\nIf we can assume that `faccessat2` is available, that simplifies things quite a bit -- this wrapper effectively reduces to `__faccessat2(...)`. That\u0027s exactly what you\u0027re suggesting, if I understand correctly?\n\nBTW out of curiosity, is there a precedent in bionic for adding functionality that depends on new kernel features without a fallback? Presumably those changes come with a big \"don\u0027t attempt to backport\" warning. ðŸ˜Š\n\n\u003e we\u0027ll only use faccessat2() in apps on devices running \u003e\u003d V, and they can\u0027t ship with kernels older than 5.8.\n\nWe still have some devices that launched on older kernels and may not be able to upgrade (because vendor BSP).\n\nI don\u0027t mind implementing a version that uses `faccessat2()` -- it\u0027s certainly a cleaner approach if we don\u0027t need to worry about compatibility with older kernels -- but I worry that it would be a solution that I can\u0027t use. We may need to maintain a separate fix internally for the time being.",
      "parentUuid": "0dc446e5_97d73db1",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}