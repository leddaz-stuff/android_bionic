{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7f28c76b_3112497b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-15T01:58:01Z",
      "side": 1,
      "message": "We ran into this at Meta while testing bpftrace compiled against libbpf 1.2.2 (from ExtendedAndroidTools [1]), which failed to load BTF data on account of calling faccessat() with AT_EACCESS [2]. I suspect similar issues may arise once Android updates external/libbpf to a newer version.\n\nHaving limited support for AT_EACCESS (i.e. allowing it only when it doesn\u0027t actually need to do anything) isn\u0027t ideal. However, given the comment about Android not running code with euid!\u003duid, I figured it may be better to not error out (and break user code) in the case that _is_ supported.\n\nAn alternative would be to fix all users of AT_EACCESS to first check if libc supports it, but that may be impractical.\n\n[1] https://github.com/facebookexperimental/ExtendedAndroidTools\n[2] https://github.com/libbpf/libbpf/blob/0c54691bae75cdf50c43be3ff5ac3b201fc94ba2/src/btf.c#L4951",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "87188cb7_0f68c488",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-15T22:57:27Z",
      "side": 1,
      "message": "(/me wonders why +maennich hasn\u0027t noticed this with AOSP\u0027s libbpf...)",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6186034_7ee1b441",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-15T16:15:38Z",
      "side": 1,
      "message": "if we\u0027re going to allow AT_EACCESS, it might make more sense to revisit this decision instead?",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59937ea6_baa2eac3",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-15T16:55:51Z",
      "side": 1,
      "message": "Since there\u0027s still a number of devices running older kernels, I think we\u0027d also need to have a fallback path that allows `AT_EACCESS` without using `faccessat2()`.\n\nI was hesitant to make the code more complicated given that AFAIK we don\u0027t have a use case that would require _fully_ supporting these flags (rather than just the `uid\u003d\u003deuid` case, where `AT_EACCESS` can be ignored), but happy to revisit if you think that\u0027d be cleaner.",
      "parentUuid": "c6186034_7ee1b441",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dc446e5_97d73db1",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-15T20:37:58Z",
      "side": 1,
      "message": "\u003e Since there\u0027s still a number of devices running older kernels, I think we\u0027d also need to have a fallback path that allows AT_EACCESS without using faccessat2().\n\nwe\u0027ll only use faccessat2() in apps on devices running \u003e\u003d V, and they can\u0027t ship with kernels older than 5.8.\n\n_static_ binaries will be affected, but they\u0027re only ever quasi-supported anyway. lots of stuff doesn\u0027t work there. we certainly have no precedent for checking the kernel version to choose a syscall, and you can\u0027t \"fall back\" on Android like you would in other libcs because you\u0027re already dead from the SIGSYS you got from trying a syscall that\u0027s not in the seccomp filter.\n\n\u003e I was hesitant to make the code more complicated\n\ndefine \"complicated\". i think _you_ mean \"more complicated to test\", whereas i mean \"fewer lines of source and fewer special cases\" :-)\n\n(given that we support AT_SYMLINK_NOFOLLOW elsewhere, i was assuming we\u0027d just let faccessat2()/seccomp/selinux policy decide that --- if someone really wants to block it, they should do it properly. in the meantime, i see there\u0027s another new flag in the kernel that hasn\u0027t made it to the man page yet, which seems like another argument for \"yeah, let\u0027s do this properly now\".)\n\nbtw, only do this if it sounds like fun --- if you\u0027re thinking \"well, okay, but that\u0027s more than i was signing up for\", just say and i\u0027ll make those changes for you. (it\u0027s mildly intricate if you haven\u0027t done it before, but grepping for `__faccessat` should let you copy \u0026 paste your way through. that\u0027s certainly what i\u0027d do if it were me :-) )",
      "parentUuid": "59937ea6_baa2eac3",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "732ebccc_a755063d",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-15T22:16:01Z",
      "side": 1,
      "message": "Appreciate your feedback @enh@google.com!\n\n\u003e i think you mean \"more complicated to test\", whereas i mean \"fewer lines of source and fewer special cases\" :-)\n\nI was under the assumption that we\u0027d need to support kernels that don\u0027t have `faccessat2()`, so by \"more complicated\" I meant a bunch of extra code (a way to detect if the syscall exists, plus the same fallback path as currently implemented that checks if euid matches uid etc.) to support a flag that we may not have a use for (yet?)\n\nIf we can assume that `faccessat2` is available, that simplifies things quite a bit -- this wrapper effectively reduces to `__faccessat2(...)`. That\u0027s exactly what you\u0027re suggesting, if I understand correctly?\n\nBTW out of curiosity, is there a precedent in bionic for adding functionality that depends on new kernel features without a fallback? Presumably those changes come with a big \"don\u0027t attempt to backport\" warning. ðŸ˜Š\n\n\u003e we\u0027ll only use faccessat2() in apps on devices running \u003e\u003d V, and they can\u0027t ship with kernels older than 5.8.\n\nWe still have some devices that launched on older kernels and may not be able to upgrade (because vendor BSP).\n\nI don\u0027t mind implementing a version that uses `faccessat2()` -- it\u0027s certainly a cleaner approach if we don\u0027t need to worry about compatibility with older kernels -- but I worry that it would be a solution that I can\u0027t use. We may need to maintain a separate fix internally for the time being.",
      "parentUuid": "0dc446e5_97d73db1",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d617116_fc7842db",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-15T22:53:12Z",
      "side": 1,
      "message": "\u003e If we can assume that faccessat2 is available, that simplifies things quite a bit -- this wrapper effectively reduces to __faccessat2(...). That\u0027s exactly what you\u0027re suggesting, if I understand correctly?\n\ncorrect.\n\n\u003e BTW out of curiosity, is there a precedent in bionic for adding functionality that depends on new kernel features without a fallback? Presumably those changes come with a big \"don\u0027t attempt to backport\" warning. ðŸ˜Š\n\nwe only backport security fixes, so this just doesn\u0027t come up.\n\nthe tricky part is the \"wait until the relevant lower-bound kernel is guaranteed to be present on all devices getting the next version of the OS\". let\u0027s consult the sheet ... https://source.android.com/docs/core/architecture/kernel/android-common#feature-and-launch-kernels ... ugh. so it was possible to ship a _new_ 2022 device with a 5.4 kernel, so it\u0027s 2025/2026 before you can assume that a bionic patch (even ignoring static binaries) actually goes to devices guaranteed to have 5.8+ :-(\n\n\u003e I don\u0027t mind implementing a version that uses faccessat2() -- it\u0027s certainly a cleaner approach if we don\u0027t need to worry about compatibility with older kernels -- but I worry that it would be a solution that I can\u0027t use. We may need to maintain a separate fix internally for the time being.\n\nfwiw, i realized i was wrong about the SIGSYS part earlier --- the seccomp filter is paired with the bionic version. so static binaries are still screwed, but dynamic binaries could try faccessat2(2) and fall back to faccessat(2).\n\nbut if you\u0027re actually trying to fix old devices you can\u0027t get a new kernel on, we\u0027re back to \"do we really want another hack on top of the existing ones in 2023?\".\n\nyou could argue that there is some precedent; this, for example:\n```\n// O_TMPFILE isn\u0027t available until Linux 3.11, so we fall back to this on\n// older kernels. AOSP was on a new enough kernel in the Lollipop timeframe,\n// so this code should be obsolete by 2025.\n```\nbut (a) tmpfile() is a much more heavily used api, more likely to be used in static binaries, and (b) that was probably added at a time when we still had devices in CI running old enough kernels that we tested both paths (even if the fallback path probably hasn\u0027t been tested in several years now).\n\ndo you _know_ you have a too-old kernel, or just fear that you do? (because if you\u0027re the only user, and you don\u0027t _need_ the backwards compatibility to old kernels, then faccessat2(2) falling back to the current code sgtm.)",
      "parentUuid": "732ebccc_a755063d",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eaa47695_d3e50210",
        "filename": "libc/bionic/faccessat.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2023-11-16T02:57:25Z",
      "side": 1,
      "message": "\u003e so it was possible to ship a new 2022 device with a 5.4 kernel, so it\u0027s 2025/2026 before you can assume that a bionic patch (even ignoring static binaries) actually goes to devices guaranteed to have 5.8+ :-(\n\nFrom https://source.android.com/docs/core/architecture/kernel/android-common#compatibility-between-kernels, looks like Android 14 is still supported on 4.14. Unless V switches to 5.10 as the oldest supported kernel (meaning that, for example, devices launched in 2022 may not be able to upgrade to V if they\u0027re stuck on 5.4), just calling `faccessat2()` unconditionally is not feasible, no?\n\nI didn\u0027t get a chance to take a closer look at seccomp yet so please correct me if my understanding is wrong. Assuming the seccomp filter is guaranteed to be in sync with `SYSCALLS.txt`, then checking for `ENOSYS` + fallback should be possible, one exception being binaries running on older platforms but statically linked against newer libc? I\u0027ll give that a try.\n\nI\u0027m still on the fence whether it\u0027s worth adding that hack given there are currently no uses of these flags (except the no-op case for `AT_EACCESS`) and eventually we\u0027ll be able to replace this with just `__faccessat2()`, but it shouldn\u0027t be too bad.\n\n\u003e do you know you have a too-old kernel\n\nYes. ðŸ˜ž For example, Meta Quest 2 is still on 4.19, and may stay there until EOL.\n\n\u003e (/me wonders why +maennich hasn\u0027t noticed this with AOSP\u0027s libbpf...)\n\nI initially thought this was because external/libbpf is still an older version, but I see now there was a recent upgrade (aosp/2790399). `AT_EACCESS` is only used in a few places (e.g. `btf__load_vmlinux_btf()`, which `bpftrace` calls), and code in AOSP that uses libbpf may not be hitting those code paths.",
      "parentUuid": "8d617116_fc7842db",
      "revId": "c0a60f13cd24d4b123a84d6b20f1877b8026b323",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}