{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1def055d_0d307e0d",
        "filename": "libc/arch-x86_64/string/avx2-memset-kbl.S",
        "patchSetId": 1
      },
      "lineNbr": 124,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-07-26T15:36:41Z",
      "side": 1,
      "message": "This is mostly, though not entorely, about pre-existing code ...\n\nI presume this is on the order of small number of MB? So the timing tests don\u0027t cover non_temporal_loop at all?\n\nIIUC, the non_temporal_loop may run for a long time, and only uses the xmm registers. Does it make sense to move the vzeroupper above it?\n\nIf the constant really is what it claims, then this threshold seems way too large. We\u0027re potentially letting a single memset blow out the entire machine\u0027s caches. That may help memset performance (or not), but it\u0027s unlikely to help application performance.",
      "range": {
        "startLine": 124,
        "startChar": 5,
        "endLine": 124,
        "endChar": 31
      },
      "revId": "95b234ca8d4899253ad21e47a5edadcc2b47aab2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed091c59_1c72bbe1",
        "filename": "libc/arch-x86_64/string/avx2-memset-kbl.S",
        "patchSetId": 1
      },
      "lineNbr": 124,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-07-26T16:11:35Z",
      "side": 1,
      "message": "yeah, 1MiB. (hard-coded from silvermont days; this symbol is a glibc-ism that intel included [presumably because all their libc submissions come from the One True Internal Source], and we always take the hard-coded SHARED_CACHE_SIZE.)\n\ni was very tempted to just delete all of the nt stuff (in the SSE2 copy of this code too)... thoughts?",
      "parentUuid": "1def055d_0d307e0d",
      "range": {
        "startLine": 124,
        "startChar": 5,
        "endLine": 124,
        "endChar": 31
      },
      "revId": "95b234ca8d4899253ad21e47a5edadcc2b47aab2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b10fbc39_97ec03d4",
        "filename": "libc/arch-x86_64/string/avx2-memset-kbl.S",
        "patchSetId": 1
      },
      "lineNbr": 124,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-07-26T16:38:43Z",
      "side": 1,
      "message": "It\u0027s hard to guess here. With an ART bias, my preference would be to set the threshold so that anything larger than a couple of pages (or maybe half L1-size?) uses the non-temporal path. But really we want a programmer hint here: Are they going to use the data shortly, or are they clearing it because they\u0027re done with it, and need it to be cleared for next use, as ART does since Nicolas\u0027 recent patch? Unfortuntely, we don\u0027t have that hint. And I think guessing wrong here is going to have a very large impact.",
      "parentUuid": "ed091c59_1c72bbe1",
      "range": {
        "startLine": 124,
        "startChar": 5,
        "endLine": 124,
        "endChar": 31
      },
      "revId": "95b234ca8d4899253ad21e47a5edadcc2b47aab2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}