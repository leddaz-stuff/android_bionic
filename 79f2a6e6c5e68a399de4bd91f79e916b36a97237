{
  "comments": [
    {
      "key": {
        "uuid": "f9a74f88_c71c80c8",
        "filename": "libc/dns/gethnamaddr.c",
        "patchSetId": 15
      },
      "lineNbr": 504,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "Care to use an a symbolic constant for the mark as well here? (Perhaps something like MARK_UNSET.) We might end up not  needing it, but changing a #define from 0 to something else is a lot easier than finding all the 0 values that need to be changes.",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9a74f88_e7941cb8",
        "filename": "libc/dns/include/resolv_netid.h",
        "patchSetId": 15
      },
      "lineNbr": 49,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "Somehow this still seems to be the odd one out. Everything else here could plausibly be called by things outside bionic/netd, but the xxx_proxy functions are really only internal.\n\nI guess the question is why is this here? And if this is here, why are all the other xxx_proxy functions not here too?",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19ab4358_8e7a1fcb",
        "filename": "libc/dns/include/resolv_netid.h",
        "patchSetId": 15
      },
      "lineNbr": 51,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "This line is 132 characters long. Since this is a new file, care to enforce a line limit? 80 is probably fine for C code but we use 100 in other places as well.",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9a74f88_67b7cc6b",
        "filename": "libc/dns/net/getnameinfo.c",
        "patchSetId": 15
      },
      "lineNbr": 111,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "Line length?",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39ae4766_5b238739",
        "filename": "libc/dns/net/getnameinfo.c",
        "patchSetId": 15
      },
      "lineNbr": 161,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "Pre-existing, but... why does this function\u0027s name not end in ...fornet_proxy? It seems like it should, since it takes a netid.\n\nObviously, if you simply renamed it, it would clash with the function that it calls (three lines down), which makes me wonder why the two functions exist and why they are different.\n\nSince these functions are internal, we should be free to rename them to something less confusing.\n\nThoughts?",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39ae4766_fb5cb3b6",
        "filename": "libc/dns/net/getnameinfo.c",
        "patchSetId": 15
      },
      "lineNbr": 331,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "Pre-existing, but I can\u0027t seem to make any sense of this. If I\u0027m reading the (previous) code correctly, then:\n\n  1. We do a query using android_gethostbyaddr_proxy.\n  2. This calls android_gethostbyaddrforiface_proxy.\n  3. If android_gethostbyaddrforiface_proxy succeeds, then it\n     returns a non-NULL result. Then android_gethostbyaddr_proxy\n     returns the length of the name, and then hostnamelen\n     \u003e\u003d 0. We return a (possibly truncated to MAXDNAME\n     characters) name. Fair enough.\n  4. If android_gethostbyaddrforiface_proxy fails, it returns\n     NULL. Then android_gethostbyaddr_proxy returns 0, and\n     then hostnamelen \u003d 0. hp \u003d NULL. So far so good.\n  5. Having covered the case where hostnamelen \u003e 0, and\n     then the case where !hostnamelen (i.e., hostnamelen \u003d\u003d\n     0), we now proceed to say, \"} else {...\" So we\u0027re checking\n     if hostnamelen \u003c 0... but that cannot happen, because\n     android_gethostbyaddr_proxy either returns 0 or\n     strlen(hostResult-\u003eh_name), which can never be negative.\n  6. In this case that cannot happen, we turn around and retry\n     the same query using android_gethostbyaddrforiface\n     directly, as if we hoping that doing so would possibly lead\n     to a result that was different from the one obtained in step\n     3.\n\nIs that analysis make sense? Or am I missing something?\n\nIf the analysis is incorrect and that extra branch does nothing, then what should we do here?\n\nWe don\u0027t necessarily have to fix it in this change, but if the code doesn\u0027t make sense then we should at least put a TODO in to fix it.",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19ab4358_79dd2f84",
        "filename": "libc/dns/resolv/res_cache.c",
        "patchSetId": 15
      },
      "lineNbr": 1235,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "Does anything actually use the CacheInfo typedef? I see various uses of \"struct resolv_cache_info\", but none of CacheInfo. Similarly for Cache. I wonder if they\u0027re worth deleting? (If it is, it doesn\u0027t have to be in this change.)",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19ab4358_19e2fb43",
        "filename": "libc/dns/resolv/res_cache.c",
        "patchSetId": 15
      },
      "lineNbr": 2037,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "\"xxx_for_netid\" \u003d\u003e \"xxx_for_net\"\n\nor\n\n\"%s ...\", __func__);",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39ae4766_bb663b81",
        "filename": "libc/dns/resolv/res_send.c",
        "patchSetId": 15
      },
      "lineNbr": 403,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-04-01T15:06:08Z",
      "side": 1,
      "message": "I don\u0027t understand this comment. Does it mean that every time we do a DNS lookup on a network that is different from the previous network we did a DNS lookup on, we throw away and repopulate the resolve private data?\n\nIf so, perhaps we should add a TODO to stop doing that, and just maintain one copy of res_state per network.",
      "revId": "79f2a6e6c5e68a399de4bd91f79e916b36a97237",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}