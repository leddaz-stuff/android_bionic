#!/bin/env python

"""Generate the compilation target feature printing source code.

The source code for detecting target features is heavily redundant
and copy-pasted, and is easier to maintain using a generative script.

This script creates the source and the include files in its current
directory.
"""

import argparse
from pathlib import Path
from typing import Dict, List, Iterable

_PRELUDE: str = """\
/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////
// !!! AUTOGENERATED FILE. CHANGES TO THIS FILE WILL BE OVERWRITTEN. !!!
////////////////////////////////////////////////////////////////////////

"""

_CPP_BOILERPLATE: str = (
    _PRELUDE
    + """\
#include <stdio.h>

#define TO_STRING_EXP(DEF) #DEF
#define TO_STRING(DEF) TO_STRING_EXP(DEF)
"""
)

_HEADER_TEMPLATE: str = (
    _PRELUDE
    + """\
#pragma once
"""
)


_FEATURES = {
    "Aarch64": [
        "__ARM_FEATURE_AES",
        "__ARM_FEATURE_BTI",
        "__ARM_FEATURE_CRC32",
        "__ARM_FEATURE_CRYPTO",
        "__ARM_FEATURE_PAC_DEFAULT",
    ],
    "Arm32": [
        "__ARM_ARCH_ISA_THUMB",
        "__ARM_FEATURE_AES",
        "__ARM_FEATURE_BTI",
        "__ARM_FEATURE_CRC32",
        "__ARM_FEATURE_CRYPTO",
        "__ARM_FEATURE_PAC_DEFAULT",
    ],
    "X86": [
        "__AES__",
        "__AVX__",
        "__CRC32__",
        "__POPCNT__",
    ],
    "Riscv": [
        "__riscv_vector",
    ],
}


def _make_function_sig(name: str) -> str:
    return f"void print{name}TargetFeatures()"


def check_template(define: str) -> List[str]:
    return [
        f"#if defined({define})",
        f'  printf("%s=%s\\n", TO_STRING_EXP({define}), TO_STRING({define}));',
        "#else",
        f'  printf("%s not defined\\n", TO_STRING_EXP({define}));',
        "#endif",
    ]


def generate_cpp_file(define_mapping: Dict[str, List[str]]) -> List[str]:
    out: List[str] = _CPP_BOILERPLATE.split("\n")
    for target, defines in define_mapping.items():
        out.append("")
        out.extend(generate_print_function(target, defines))
    return out


def generate_print_function(name: str, defines: List[str]) -> List[str]:
    """Generate a print<DEFINE>TargetFeatures function."""
    function_body = [_make_function_sig(name) + " {"]
    for d in defines:
        function_body.extend(check_template(d))
    function_body.append("}")
    return function_body


def generate_header(define_names: Iterable[str]) -> List[str]:
    return _HEADER_TEMPLATE.split("\n") + [
        _make_function_sig(name) + ";\n" for name in define_names
    ]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    return parser.parse_args()


def main() -> None:
    parse_args()
    current_dir = Path(__file__).parent
    printer_cpp_filepath = current_dir / "print_target_features.cpp"
    printer_cpp_filepath.write_text(
        "\n".join(generate_cpp_file(_FEATURES)), encoding="utf-8"
    )
    include_dir = current_dir / "include"
    include_dir.mkdir(exist_ok=True)
    printer_header_filepath = include_dir / "print_target_features.h"
    printer_header_filepath.write_text(
        "\n".join(generate_header(_FEATURES.keys())), encoding="utf-8"
    )


if __name__ == "__main__":
    main()
