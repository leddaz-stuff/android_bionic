{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f6b1e3ad_5ecee2b5",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 249,
      "author": {
        "id": 1128769
      },
      "writtenOn": "2021-07-21T15:21:50Z",
      "side": 1,
      "message": "optional nit: this comment used to refer to the 1/2/3 cases below, but is now more disassociated due to the new if-case. Consider rephrasing (e.g. list out the possibilities as part of this comment), or even remove \"There are three possible configurations:\", as it\u0027s repeating the logic.",
      "range": {
        "startLine": 249,
        "startChar": 9,
        "endLine": 249,
        "endChar": 33
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "65faf4e9_ab9eb935",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 249,
      "author": {
        "id": 1268571
      },
      "writtenOn": "2021-07-27T11:04:27Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "f6b1e3ad_5ecee2b5",
      "range": {
        "startLine": 249,
        "startChar": 9,
        "endLine": 249,
        "endChar": 33
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b79861a_cff6f878",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 251,
      "author": {
        "id": 1128769
      },
      "writtenOn": "2021-07-21T15:21:50Z",
      "side": 1,
      "message": "Am I understanding it correctly that gPreviousDefaultDispatchTable is now set once, and sticks for the lifetime of the process, even if there are successful DispatchResets? (I might be missing some pointer indirection.).\n\nIf so, that implies that the default dispatch never changes beyond the first HandleHeapprofdSignal entry, right? Is that a safe assumption, or can e.g. gwp asan be initialized beyond process startup?",
      "range": {
        "startLine": 251,
        "startChar": 21,
        "endLine": 251,
        "endChar": 50
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "80cee4c8_f082387f",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 251,
      "author": {
        "id": 1268571
      },
      "writtenOn": "2021-07-27T11:04:27Z",
      "side": 1,
      "message": "Yes, GWP ASAN is only initialized at startup.",
      "parentUuid": "6b79861a_cff6f878",
      "range": {
        "startLine": 251,
        "startChar": 21,
        "endLine": 251,
        "endChar": 50
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff5f47ba_d0b7b1ba",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2021-07-21T17:02:13Z",
      "side": 1,
      "message": "This branch can be explicit based on the value of gHeapprofdState, and it\u0027s much clearer that way and avoids an unnecessary atomic load in the general case. Like this:\n\n  // We cannot grab the mutex here, as this is used in a signal handler.\n  MaybeModifyGlobals(kWithoutLock, [] {\n    MallocHeapprofdState initial_state \u003d kInitialState;\n    // If hooks are already installed, we still want to install ephemeral hooks\n    // to retrigger heapprofd client initialization.\n    MallocHeapprofdState hook_installed \u003d kHookInstalled;\n\n    // Below, we initialize heapprofd lazily by redirecting libc\u0027s malloc() to\n    // call MallocInitHeapprofdHook, which spawns off a thread and initializes\n    // heapprofd. During the short period between now and when heapprofd is\n    // initialized, allocations may need to be serviced. There are four possible\n    // configurations, described below.\n    if (atomic_compare_exchange_strong(\u0026gHeapprofdState, \u0026initial_state,\n                                       kInstallingEphemeralHook)) {\n      const MallocDispatch *default_dispatch \u003d GetDefaultDispatchTable();\n\n      if (default_dispatch \u003d\u003d nullptr) {\n        //  1. No malloc hooking has been done (heapprofd, GWP-ASan, etc.). In\n        //  this case, everything but malloc() should come from the system\n        //  allocator.\n        atomic_store(\u0026gPreviousDefaultDispatchTable, nullptr);\n        gEphemeralDispatch \u003d *NativeAllocatorDispatch();\n      } else if (DispatchIsGwpAsan(default_dispatch)) {\n        //  2. GWP-ASan was installed. We should use GWP-ASan for everything but\n        //  malloc() in the interim period before heapprofd is properly\n        //  installed. After heapprofd is finished installing, we will use\n        //  GWP-ASan as heapprofd\u0027s backing allocator to allow heapprofd and\n        //  GWP-ASan to coexist.\n        atomic_store(\u0026gPreviousDefaultDispatchTable, default_dispatch);\n        gEphemeralDispatch \u003d *default_dispatch;\n      } else {\n        // 3. It may be possible at this point in time that heapprofd is\n        // *already* the default dispatch, and as such we don\u0027t want to use\n        // heapprofd as the backing store for itself (otherwise infinite\n        // recursion occurs). We will use the system allocator functions. Note:\n        // We\u0027ve checked that no other malloc interceptors are being used by\n        // validating `gHeapprofdIncompatibleHooks` above, so we don\u0027t need to\n        // worry about that case here.\n        atomic_store(\u0026gPreviousDefaultDispatchTable, nullptr);\n        gEphemeralDispatch \u003d *NativeAllocatorDispatch();\n      }\n    } else if (atomic_compare_exchange_strong(\u0026gHeapprofdState, \u0026hook_installed,\n                                              kInstallingEphemeralHook)) {\n      // 4. We\u0027re looking to re-initialize the hooks. We already have a\n      // previous dispatch table marked, and we should use it for the\n      // ephemeral dispatch as well.\n      const MallocDispatch *prev_dispatch \u003d\n          atomic_load(\u0026gPreviousDefaultDispatchTable);\n      gEphemeralDispatch \u003d *prev_dispatch;\n    } else {\n      error_log(\"%s: heapprofd: failed to transition kInitialState -\u003e \"\n                \"kInstallingEphemeralHook. current state (possible race): %d\",\n                getprogname(), expected2);\n      return;\n    }\n\n    // Now, replace the malloc function so that the next call to malloc() will\n    // initialize heapprofd.\n    gEphemeralDispatch.malloc \u003d MallocInitHeapprofdHook;\n\n    // And finally, install these new malloc-family interceptors.\n    __libc_globals.mutate([](libc_globals *globals) {\n      atomic_store(\u0026globals-\u003edefault_dispatch_table, \u0026gEphemeralDispatch);\n      if (!MallocLimitInstalled()) {\n        atomic_store(\u0026globals-\u003ecurrent_dispatch_table, \u0026gEphemeralDispatch);\n      }\n    });\n    atomic_store(\u0026gHeapprofdState, kEphemeralHookInstalled);\n  });",
      "range": {
        "startLine": 253,
        "startChar": 10,
        "endLine": 253,
        "endChar": 34
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c7cd368_657c37c1",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1268571
      },
      "writtenOn": "2021-07-27T11:04:27Z",
      "side": 1,
      "message": "I guess that is neater (the extra load is completely irrelevant though). Thanks.",
      "parentUuid": "ff5f47ba_d0b7b1ba",
      "range": {
        "startLine": 253,
        "startChar": 10,
        "endLine": 253,
        "endChar": 34
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c324b8c_39e4abb4",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 456,
      "author": {
        "id": 1128769
      },
      "writtenOn": "2021-07-21T15:21:50Z",
      "side": 1,
      "message": "Sanity check: did you consider interplay with malloc_limit? Don\u0027t remember if it ever affects the default dispatch table.",
      "range": {
        "startLine": 456,
        "startChar": 13,
        "endLine": 456,
        "endChar": 33
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08c41c9c_9836cc5c",
        "filename": "libc/bionic/malloc_heapprofd.cpp",
        "patchSetId": 6
      },
      "lineNbr": 456,
      "author": {
        "id": 1268571
      },
      "writtenOn": "2021-07-27T11:04:27Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "1c324b8c_39e4abb4",
      "range": {
        "startLine": 456,
        "startChar": 13,
        "endLine": 456,
        "endChar": 33
      },
      "revId": "56babd2b05ef389e616c5f8dec657c768e342bd6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}