{
  "comments": [
    {
      "key": {
        "uuid": "0d031dc0_2d421bff",
        "filename": "tools/relocation_packer/src/elf_file.cc",
        "patchSetId": 1
      },
      "lineNbr": 318,
      "author": {
        "id": 1041673
      },
      "writtenOn": "2015-05-22T17:44:38Z",
      "side": 1,
      "message": "why? If p_align is \u003e page_size for some other architecture shouldn\u0027t we still adjust it?",
      "revId": "818c14107d07de5ba064798c52d9030904591f2b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed8889a6_85d6c6ea",
        "filename": "tools/relocation_packer/src/elf_file.cc",
        "patchSetId": 1
      },
      "lineNbr": 318,
      "author": {
        "id": 1037287
      },
      "writtenOn": "2015-05-26T12:36:04Z",
      "side": 1,
      "message": "The core issue is not packing but rather unpacking.  That is, reversibility.\n\nIf we encounter a p_align value of 4kb on unpacking, we need to decide whether or not to set it to 64kb.  We should if we reduced it on packing, but not if it was already 4kb before packing.  For now I\u0027m inferring which applies from the architecture.\n\nOne other way of doing this suggests itself.\n\nOn all architectures that we care about, ELF executables have two LOAD segments with the same p_align for each.  On packing we only reduce one segment\u0027s p_align, and leave the other unchanged.  So... on unpacking we could look at the other LOAD segment -- the one we didn\u0027t mess with on packing -- and then set the p_align of this one to match the other.  This embeds the assumption that LOAD segments always have the same p_align.",
      "parentUuid": "0d031dc0_2d421bff",
      "revId": "818c14107d07de5ba064798c52d9030904591f2b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}