{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c4c43915_f943b3d3",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-07T20:28:49Z",
      "side": 1,
      "message": "is this true? surely if you\u0027re not using REG_PEND, this is null?",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d055db3c_2632367c",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2022-11-09T01:15:36Z",
      "side": 1,
      "message": "I search where `re_endp` is used and find it in http://cs/android/bionic/libc/upstream-netbsd/lib/libc/regex/regcomp.c;l\u003d258;rcl\u003d6e903559015ea22c810c2495e6bc845aa2272ac9. If it is null, I think there will be a segment fault.",
      "parentUuid": "c4c43915_f943b3d3",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81ab4a57_86bec9b7",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-09T16:26:57Z",
      "side": 1,
      "message": "yes, but look at the line before the dereference:\n```\n\tif (cflags\u0026REG_PEND) {\n\t\tif (preg-\u003ere_endp \u003c pattern)\n```\nlike i said, this field is only used *if* you\u0027re using `REG_PEND`, which isn\u0027t the default.\n\n(i\u0027m assuming we can\u0027t just leave the pointers in *structs* unannotated? i assume we get an error if we annotate the functions but not the structs? otherwise i\u0027d be tempted to not annotate _any_ structs because it\u0027s inherently a bit complicated to know what the annotations mean. i mean, even if it\u0027s not legit to pass/return a struct with a null field, `static struct foo_t foo;` is still going to give you a struct that has a null field. i _think_ the most reasonable interpretation of annotations on struct fields is that one i mentioned --- \"this is the \u0027lower bound\u0027 of what _callers_ guarantee on entry and what _callees_ guarantee on exit\". in which case, i think this is `_Nullable` because it\u0027s actually _meaningless_ unless you\u0027re using `REG_PEND`.)",
      "parentUuid": "d055db3c_2632367c",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b850388d_66649e55",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2022-11-09T22:43:41Z",
      "side": 1,
      "message": "\u003e i\u0027m assuming we can\u0027t just leave the pointers in structs unannotated? \n\nunfortunately no ðŸ˜ž Build error here\n```\n/usr/local/google/home/zijunzhao/real-aosp/aosp-master-with-phones/bionic/libc/include/regex.h:52:13: note: insert \u0027_Nullable\u0027 if the pointer may be null\n        const char * re_endp;   /* end pointer for REG_PEND */\n                   ^\n                     _Nullable\n/usr/local/google/home/zijunzhao/real-aosp/aosp-master-with-phones/bionic/libc/include/regex.h:52:13: note: insert \u0027_Nonnull\u0027 if the pointer should never be null\n        const char * re_endp;   /* end pointer for REG_PEND */\n                   ^\n                     _Nonnull\n```\nI see. So developers help guarantee the safety?",
      "parentUuid": "81ab4a57_86bec9b7",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1476056_a51d114f",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-09T23:24:37Z",
      "side": 1,
      "message": "it\u0027s C --- nothing is safe :-(\n\nwith a lot of these APIs you just have to know when something is/isn\u0027t valid. like i said the other day --- these annotations are probably best as a guide for writing _new_ api that isn\u0027t terrible (where you wouldn\u0027t expose struct members at all; you\u0027d have an opaque struct and getter/setter functions to act on it instead).\n\nretrofitting the annotations to ancient api is going to be interesting. (and why i wish we could just skip structs.)",
      "parentUuid": "b850388d_66649e55",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "239f2808_fc4b113a",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-10T19:55:44Z",
      "side": 1,
      "message": "fwiw (unless danalbert disagrees), reading the clang docs i actually think `_Null_unspecified` makes sense for these struct fields... \"The _Null_unspecified nullability qualifier indicates that neither the _Nonnull nor _Nullable qualifiers make sense for a particular pointer type. It is used primarily to indicate that the role of null with specific pointers in a nullability-annotated header is unclear, e.g., due to overly-complex implementations or historical factors with a long-lived API.\"\n\nhttps://clang.llvm.org/docs/AttributeReference.html#null-unspecified\n\ni mean, that sums up the case here pretty well, i think? \"one of these is too complicated to express, because it depends on the flags passed to other functions\" and \"one of these is -- as the comment says -- none of your business [and just an implementation detail]\" :-)",
      "parentUuid": "c1476056_a51d114f",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c227103_9576fed9",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-07T20:28:49Z",
      "side": 1,
      "message": "i\u0027m not sure this is true either? it\u0027ll be null if you haven\u0027t yet called regcomp(), for example. (is this one a legit use case for the \"undefined\" option?)",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a737412c_3ea2eb6e",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2022-11-09T01:15:36Z",
      "side": 1,
      "message": "Same concern here. http://cs/android/bionic/libc/upstream-netbsd/lib/libc/regex/regexec.c;l\u003d210;rcl\u003d6e903559015ea22c810c2495e6bc845aa2272ac9 If making `re_g` nullable, visiting `g-\u003emagic` will access invalid memory? I am not sure whether it should be `__null_unspecified`. All cases in the code search are related to apple code ðŸ˜ž. And according to swift tutorial, `__null_unspecified` bridges to a Swift implicitly-unwrapped optional and it is default. In other words, without specifying, this pointer is nullable by default in my view. Same, the example above is nothing to do with specification. So I still think it is safer to be `__Nonnull`?",
      "parentUuid": "7c227103_9576fed9",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63520413_eca4ac99",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-09T16:26:57Z",
      "side": 1,
      "message": "and same argument here ... you can\u0027t call `regexec()` before you call `regcomp()`, and by definition the values in this struct are undefined until you call `regcomp()`.\n\ni guess i don\u0027t know what compiler warnings we get from annotating struct fields...\n\ndoes saying `_Nonnull` here cause a warning for code like this (which would be wrong):\n```\n  regex_t re \u003d {};\n  regcomp(\u0026re, \"abc\", 0);\n```\n(and if not, what _does_ the annotation do?)",
      "parentUuid": "a737412c_3ea2eb6e",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a175be5_5ff8e63c",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2022-11-09T22:43:41Z",
      "side": 1,
      "message": "\u003e  you can\u0027t call regexec() before you call regcomp()\n\nI haven\u0027t found this in the code search ðŸ˜® I guess I miss something!\n\n\u003e (and if not, what does the annotation do?)\nyes, there is no warning ðŸ˜•",
      "parentUuid": "63520413_eca4ac99",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c27a339b_00f921c9",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-09T23:24:37Z",
      "side": 1,
      "message": "see https://man7.org/linux/man-pages/man3/regcomp.3.html:\n```\n       regcomp() is used to compile a regular expression into a form\n       that is suitable for subsequent regexec() searches.\n\n       regcomp() is supplied with preg, a pointer to a pattern buffer\n       storage area; regex, a pointer to the null-terminated string and\n       cflags, flags used to determine the type of compilation.\n\n       All regular expression searching must be done via a compiled\n       pattern buffer, thus regexec() must always be supplied with the\n       address of a regcomp()-initialized pattern buffer.\n```\n\nor, like you said, literally the first thing regexec() does is dereference the regex_t:\n```\nint\t\t\t\t/* 0 success, REG_NOMATCH failure */\nregexec(const regex_t * __restrict preg,\n\tconst char * __restrict string,\n\tsize_t nmatch,\n\tregmatch_t pmatch[__restrict],\n\tint eflags)\n{\n\tstruct re_guts *g \u003d preg-\u003ere_g;\n```\nbecause this is C, if you just had code like\n```\n  regex_t re;\n  regexec(\u0026re, \"hello\", NULL, 0);\n```\nthe `preg-\u003ere_g` there would be undefined! or, if it was static, would be defined to be NULL. either way, that wouldn\u0027t end well...",
      "parentUuid": "0a175be5_5ff8e63c",
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ceb76c6d_4b8e89c8",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-11-07T20:28:49Z",
      "side": 1,
      "message": "is that true? surely that\u0027s an error?\n\nhere at least the DIAGASSERTs seem right:\n```\n\t_DIAGASSERT(preg !\u003d NULL);\n\t_DIAGASSERT(pattern !\u003d NULL);\n```",
      "range": {
        "startLine": 100,
        "startChar": 48,
        "endLine": 100,
        "endChar": 57
      },
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25aecec5_14b197da",
        "filename": "libc/include/regex.h",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2022-11-09T01:15:36Z",
      "side": 1,
      "message": "Sorry my bad. __regex should be _Nonnull",
      "parentUuid": "ceb76c6d_4b8e89c8",
      "range": {
        "startLine": 100,
        "startChar": 48,
        "endLine": 100,
        "endChar": 57
      },
      "revId": "1c0a16d69fc75e0e5669b4c840ada49e837a2a9d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}