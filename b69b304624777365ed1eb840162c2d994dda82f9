{
  "comments": [
    {
      "key": {
        "uuid": "ed1ff5dd_fc086a62",
        "filename": "libc/bionic/exec.cpp",
        "patchSetId": 4
      },
      "lineNbr": 54,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2020-03-30T21:17:39Z",
      "side": 1,
      "message": "+1",
      "range": {
        "startLine": 54,
        "startChar": 33,
        "endLine": 54,
        "endChar": 67
      },
      "revId": "b69b304624777365ed1eb840162c2d994dda82f9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d5c73b3_96f857f6",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 319,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2020-03-30T21:19:52Z",
      "side": 1,
      "message": "If that happens, all that goes wrong is that the non-bionic process in question doesn\u0027t get profiling and debugging signals --- not the end of the world. If that process uses those signals for its own purposes, it\u0027s going to malfunction when we send system-wide signals no matter what.",
      "range": {
        "startLine": 317,
        "startChar": 47,
        "endLine": 319,
        "endChar": 42
      },
      "revId": "b69b304624777365ed1eb840162c2d994dda82f9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc83162e_8c07ef27",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 319,
      "author": {
        "id": 1128769
      },
      "writtenOn": "2020-03-30T21:43:42Z",
      "side": 1,
      "message": "I was more concerned over the signals staying blocked for such processes, in which case the kernel would have to queue the RT signals (I believe it has to, and will keep queueing them up to the O(10k) queue limit on a typical Android device?).\n\nFTR, I don\u0027t think it\u0027d be a problem in practice regardless, given that the effective signalling rates for the reserved signals should be low.",
      "parentUuid": "5d5c73b3_96f857f6",
      "range": {
        "startLine": 317,
        "startChar": 47,
        "endLine": 319,
        "endChar": 42
      },
      "revId": "b69b304624777365ed1eb840162c2d994dda82f9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90161df8_adb25d14",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 319,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2020-03-30T21:55:54Z",
      "side": 1,
      "message": "BTW, don\u0027t we want to unblock these signals only after we set up the actual handlers? Here, you set them to SIG_IGN, then change the mask, and if we do that, we get a window where we can lose the signal. If we sigaction first and _then_ unmask, we never drop a signal.\n\n\u003e  the kernel would have to queue the RT signals (I believe it has to, and will keep queueing them up to the O(10k) queue limit \n\nI just had a wonderful idea for making fork bombs worse. :-)",
      "parentUuid": "cc83162e_8c07ef27",
      "range": {
        "startLine": 317,
        "startChar": 47,
        "endLine": 319,
        "endChar": 42
      },
      "revId": "b69b304624777365ed1eb840162c2d994dda82f9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed39c19c_b596e77d",
        "filename": "linker/linker_main.cpp",
        "patchSetId": 4
      },
      "lineNbr": 319,
      "author": {
        "id": 1128769
      },
      "writtenOn": "2020-03-30T22:14:11Z",
      "side": 1,
      "message": "I\u0027m mostly writing this for the current state of the profiling signal handlers. The assumptions are:\n* it\u0027s safe to discard the signal that was enqueued after execve\u0027s block, as it\u0027s not relevant to the new process image (even though the PID has stayed the same)\n* it\u0027s not a big deal to discard a signal that is delivered early in the process\u0027 startup (before libc/ART establish the correct signal handlers).\n\nI agree that the alternative of keeping the signals blocked until libc/ART/etc would be nice in theory (and avoid polluting the linker), but my main concern is that would be too brittle to achieve in practice. Bionic\u0027s wrappers for signal masking/blocking/unblocking transparently insert/remove the reserved handlers from the signal sets, so it\u0027s super easy for some common code to accidentally, and prematurely, unblock the reserved signals.\n\nAs an example, afaict, the destructor of ScopedSignalBlocker in the linker will end up unblocking all of the reserved signals (as the sigprocmask(SET_MASK) ends up going through reserved_signals.h\u0027s filtering): https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_tls.cpp;l\u003d63\n\nLosing some signals (early in the image\u0027s lifetime) is ok for the profilers. It might not generalise, but I\u0027m not sure how to practically guarantee that the block stays until the relevant library otherwise.",
      "parentUuid": "90161df8_adb25d14",
      "range": {
        "startLine": 317,
        "startChar": 47,
        "endLine": 319,
        "endChar": 42
      },
      "revId": "b69b304624777365ed1eb840162c2d994dda82f9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}