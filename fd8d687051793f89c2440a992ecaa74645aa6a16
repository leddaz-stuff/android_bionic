{
  "comments": [
    {
      "key": {
        "uuid": "b5af9c0d_1329633a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-09-28T21:33:08Z",
      "side": 1,
      "message": "i\u0027ll leave +2 to cferris though...",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dfd64683_66324bfa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1114194
      },
      "writtenOn": "2020-09-28T22:52:51Z",
      "side": 1,
      "message": "I didn\u0027t validated the DWARF constants in the final hunk, but I didn\u0027t seen anything obviously wrong.",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "439c48ab_798764e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-09-29T17:58:53Z",
      "side": 1,
      "message": "Were you able to test this in someway? The libunwindstack handling of the signal handler on x86 is different than this (I haven\u0027t checked the x86_64 parts thoroughly yet). The __restore looks mostly correct (except for a dereference), but the __restore_rt looks very different (and the previous cfi information looks wrong too).\n\nI\u0027m trying to test this myself by building the 64 bit cuttlefish and running some of my unwind through signal tests and disabling my special signal handling code.",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df003c2e_3fa2de7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-09-29T22:38:36Z",
      "side": 1,
      "message": "After a lot of pain trying to get cuttlefish to work, neither of the new unwinding appears to work properly. It looks like on x86_64, my unwinding code can properly guess how to do the unwind, but the unwind information is not correct. I suspect the same problem as in X86, you need a deref op.\n\nI don\u0027t know how important this is since the current unwind information looks like it\u0027s wrong too.",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8db0fb48_b7e363f0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-09-29T22:59:46Z",
      "side": 1,
      "message": "The difference between __restore and __restore_rt are the offsets from SP to the sigcontext struct. I thought I checked them against the kernel source, but maybe not. I did verify with `objdump -Wf` that none of the instructions changed, and the same offsets appear in other versions of this trampoline (e.g. in the 32-bit x86 vDSO and in x86_64 glibc).\n\nI tested it by hand, using both libgcc and the LLVM libunwind, and a test program that unwinds through the signal frame. libgcc has a fallback, but it won\u0027t use the fallback if it finds a DWARF FDE.",
      "parentUuid": "439c48ab_798764e4",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e9a563d1_94480586",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-09-29T22:59:46Z",
      "side": 1,
      "message": "IIRC I tested it by hand, using both libgcc and the LLVM libunwind, and a test program that unwinds through a signal frame. libgcc has a fallback, but AFAIK it won\u0027t use the fallback if it finds the DWARF FDE. LLVM libunwind doesn\u0027t yet have code for detecting signal frames.",
      "parentUuid": "df003c2e_3fa2de7e",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bbb0dbe1_cde3b478",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-09-29T23:45:02Z",
      "side": 1,
      "message": "This could just be a bug in my code for unwinding, because I don\u0027t interpret the ops the same way that you do. Let me look at gdb and see what they are doing and figure out what\u0027s going wrong.",
      "parentUuid": "8db0fb48_b7e363f0",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "535574cf_f598d4a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-10-01T08:04:30Z",
      "side": 1,
      "message": "I disabled RegsX86::StepIfSignalHandler and RegsX86_64::StepIfSignalHandler with a \"return false\", and tried to run the libunwindstack tests. These tests failed:\n\n  [  FAILED  ] RegsStepIfSignalHandlerTest.x86_step_if_signal_handler_no_siginfo\n  [  FAILED  ] RegsStepIfSignalHandlerTest.x86_step_if_signal_handler_siginfo\n  [  FAILED  ] RegsStepIfSignalHandlerTest.x86_64_step_if_signal_handler\n  [  FAILED  ] UnwindTest.remote_through_signal_with_invalid_func\n  [  FAILED  ] UnwindTest.remote_through_signal_sa_siginfo_with_invalid_func\n\nThese tests passed:\n\n  [       OK ] UnwindTest.remote_through_signal (49 ms)\n  [       OK ] UnwindTest.remote_through_signal_sa_siginfo (45 ms)\n\nThe RegsStepIfSignalHandlerTest test failures make sense because I disabled StepIfSignalHandler.\n\nThe remote_through_signal_with_invalid_func test forks a child, sets up a SIGSEGV handler, then calls NULL in InnerFunction:\n\n      void (*crash_func)() \u003d nullptr;\n      crash_func();\n\nThe test fails because libunwindstack doesn\u0027t show any earlier frames than the sigreturn frame. The problem is in DwarfSectionImpl\u003cAddressType\u003e::Eval:\n\n  // If the pc was set to zero, consider this the final frame.\n  *finished \u003d (cur_regs-\u003epc() \u003d\u003d 0) ? true : false;\n\nThe sigreturn frame restores the PC that faulted, which is 0. I fixed this test by plumbing through the \u0027S\u0027 flag from the CIE, then changing this code to:\n\n  // If the pc was set to zero, consider this the final frame. Exception: if\n  // this is the sigreturn frame, then we want to try to recover the real PC\n  // using the return address (from LR or the stack).\n  *finished \u003d (cur_regs-\u003epc() \u003d\u003d 0 \u0026\u0026 !cie-\u003eis_signal_frame) ? true : false;\n\nI also plumbed the \u0027is_signal_frame\u0027 flag through the Step functions, so that I could enable these adjustments:\n\nhttps://android.googlesource.com/platform/system/core/+/b05c472421d9d4dd919926c95a5c1de4eb9a721a/libunwindstack/Unwinder.cpp#248\n\nI\u0027m not saying we should make these changes to libunwindstack, but they demonstrate that this x86 FDE/CIE is working, and that libunwindstack works if it uses the sigreturn FDE.\n\nFor reference, I uploaded my libunwindstack CL to:\nhttps://android-review.googlesource.com/c/platform/system/core/+/1443619",
      "parentUuid": "bbb0dbe1_cde3b478",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f228651_b91f2d50",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-10-01T20:51:06Z",
      "side": 1,
      "message": "Thanks for the follow-up showing how this works, I was going to work on this today but now my workload is less.",
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "243b2cb0_bc16ffb2",
        "filename": "libc/arch-x86/bionic/__restore.S",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-09-29T17:58:53Z",
      "side": 1,
      "message": "Don\u0027t you need to put a dereference op here? Otherwise, the value of the register is just the value of location of the register on the stack, it\u0027s not going to get the value from the stack.",
      "range": {
        "startLine": 57,
        "startChar": 22,
        "endLine": 57,
        "endChar": 56
      },
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d23ef13_b70c343a",
        "filename": "libc/arch-x86/bionic/__restore.S",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-09-29T22:59:46Z",
      "side": 1,
      "message": "I don\u0027t think so. DW_CFA_expression provides the address of the saved value (not the value). A dereference is implied. OTOH, DW_CFA_val_expression provides the value. This is analogous to DW_CFA_offset vs DW_CFA_val_offset.",
      "parentUuid": "243b2cb0_bc16ffb2",
      "range": {
        "startLine": 57,
        "startChar": 22,
        "endLine": 57,
        "endChar": 56
      },
      "revId": "fd8d687051793f89c2440a992ecaa74645aa6a16",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}