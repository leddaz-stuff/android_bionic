{
  "comments": [
    {
      "key": {
        "uuid": "2b2600b6_cd1b696f",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-18T19:35:21Z",
      "side": 1,
      "message": "I don\u0027t think we need this repeated with every function.\n\nDan Albert is looking at why we get the error anyway.  I\u0027m not sure that\u0027s working as intended, but it probably also shouldn\u0027t slow down this work.",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 119,
        "endChar": 38
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6bd55878_aa956f29",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 144,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-18T19:35:21Z",
      "side": 1,
      "message": "That seems like a very workload-dependent prediction, and this is unlikely to be performance critical.  I wouldn\u0027t bother.",
      "range": {
        "startLine": 144,
        "startChar": 6,
        "endLine": 144,
        "endChar": 20
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6bd55878_8acd0bf0",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 276,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-18T19:35:21Z",
      "side": 1,
      "message": "Good catch!\n\nThis should always have been a loop.",
      "range": {
        "startLine": 276,
        "startChar": 2,
        "endLine": 276,
        "endChar": 8
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4b30947e_5cf4558b",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-18T19:35:21Z",
      "side": 1,
      "message": "This probably works on our current hardware, but is not technically correct.  It is likely to eventually fail on ARMv8.  A seq_cst store followed by a memory_order_relaxed load does not enforce ordering.\n\nA memory_order_release store followed by atomic_thread_fence(memory_order_seq_cst) should do, and is likely to be faster than making the loads below sequentially consistent as well.",
      "range": {
        "startLine": 327,
        "startChar": 4,
        "endLine": 327,
        "endChar": 30
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b2c4c7c_68828331",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-18T22:35:45Z",
      "side": 1,
      "message": "Do you mean if I use a seq_cst store followed by a relaxed load, the load may happen before the store on other cpus? That conflicts the standard.\nWhy the code doesn\u0027t work in ARMv8? Where can I find the reason?\nI thought the code follows the c11 standard of atomic, but in fact maybe I am still misunderstanding, can you please see my comment in __pthread_rwlock_timedwrlock/timedrdlock to find any misunderstanding in it?",
      "parentUuid": "4b30947e_5cf4558b",
      "range": {
        "startLine": 327,
        "startChar": 4,
        "endLine": 327,
        "endChar": 30
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b31d8d0_c7bc3e99",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-18T23:10:36Z",
      "side": 1,
      "message": "The reordering is allowed by the standard.  Consider (everything initially zero):\n\nThread 1:\na: x \u003d 1 seq_cst\nb: r1 \u003d y relaxed\n\nThread 2:\nc: y \u003d 1 seq_cst\nd: r2 \u003d x seq_cst\n\nI claim r1 \u003d r2 \u003d 0 is allowed.  In the SC order S\n\nc \u003c d \u003c a\n\nb sees the initializing write, not c, as does d.  There are no synchronizes-with relationships.  Hence happens-before orders only actions within a thread and initializations. The SC order S does not contribute to happens-before.  No problems.\n\nSee 29.3 in the standard.\n\nOn ARMv8, the seq_cst store can be implement as a release store, which is ordered with respect to later acquire loads, but not with respect to later ordinary loads.  The relaxed load would be an ordinary load.\n\nI think the rest of your understanding is correct.  You should just not assume that seq_cst acts as a fence with respect to other weakly ordered operations.  It\u0027s not guaranteed to.  (It does on architectures on which seq_cst is implemented with full fences.  But that\u0027s not all of them.)\n\nseq_cst was designed to provide sequential consistency for programs that only used seq_cst operations.  Its ordering properties are near minimal for achieving that goal.  Mixing it with weakly ordered operations is tricky.",
      "parentUuid": "8b2c4c7c_68828331",
      "range": {
        "startLine": 327,
        "startChar": 4,
        "endLine": 327,
        "endChar": 30
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e81a2e66_96234ac8",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-19T01:48:54Z",
      "side": 1,
      "message": "I didn\u0027t realize that the implementation of memory order is affected by what operation the function will execute. My current understanding is: For seq_cst, store operation will have to flush its cache all the way to memory (before the store?), load operation will have to wait for any flushing finished and visible (after the load?).\nIf that is right, I can understand your example, \"a\" only flushes its cache, but doesn\u0027t wait others flush, so \"b\" can read y from its cache.\n\nSo I guess atomic_thread_fence(seq_cst) implies both flush to memory and wait flushing actions. And all load-store operations with seq_cst operations imply both flush to memory and wait flushing actions. If that is right, the original code should be right as it uses compare_and_swap operations with seq_cst.\n\nBut I still wonder why you suggest to use memory order release in atomic_store and atomic_compare_exchange_weak_explicit below, as using a atomic_thread_fence(seq_cst) may already be enough. If it is for matching with memory_order_acquire in locking functions, I think it will be reasonable.",
      "parentUuid": "6b31d8d0_c7bc3e99",
      "range": {
        "startLine": 327,
        "startChar": 4,
        "endLine": 327,
        "endChar": 30
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4b30947e_dcae257f",
        "filename": "libc/bionic/pthread_rwlock.cpp",
        "patchSetId": 3
      },
      "lineNbr": 336,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-18T19:35:21Z",
      "side": 1,
      "message": "Same issue here.  Use release followed by a seq_cst fence.  It should generate the same code, so there shouldn\u0027t be a performance impact, except possibly on some future ARMv8, where the current code is incorrect.",
      "range": {
        "startLine": 336,
        "startChar": 50,
        "endLine": 336,
        "endChar": 70
      },
      "revId": "3e69aa74cfd46df4fad8a49effe9a73a81020969",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}