{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b7c7b776_39cbb778",
        "filename": "tests/utmp_test.cpp",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-01-25T00:46:27Z",
      "side": 1,
      "message": "this is still allocating a new utmp. (since EMPTY is 0, you can\u0027t actually tell the difference between the one you initialized on L33 and the new one you created here on L34, but if you print out their addresses with `printf(\"%p %p\\n\", \u0026tmp, failure.get())` you should see they have different values.)\n\ni think you just want `\u0026tmp` on L35. (https://en.cppreference.com/w/c/language/operator_member_access)\n\nbtw, although it doesn\u0027t matter in Android -- where we automatically zero every stack allocation anyway -- you might want to get into the habit of writing L32-L33 like this instead:\n```\n  utmp tmp \u003d { .ut_type \u003d EMPTY };\n```\ni personally like anyway that because it\u0027s slightly less typing, but it actually has a slightly different meaning. it\u0027s equivalent to this:\n```\n  utmp tmp \u003d {}\n  tmp.ut_type \u003d EMPTY;\n```\nwhere the first line says \"zero everything\" and the second line says \"now overwrite this one field\". what you _currently_ have:\n```\n  utmp tmp;\n  tmp.ut_type \u003d EMPTY;\n```\nactually means \"give me an _uninitialized_ struct utmp, containing whatever crap happens to be on the stack right now, and _only_ initialize one field in it\". (though, like i said, this is such a common C programming mistake that Android just says \"no, we\u0027ll always zero everything anyway\".)\n\ndon\u0027t worry about performance --- the compiler is clever enough that an explicit `\u003d {}` or `\u003d { .foo \u003d bar }` doesn\u0027t cost you _in addition_ to the implicit zeroing. any given piece of memory will only be initialized once.\n\nand, yes, if you\u0027re wondering, you can initialize multiple fields at once inside the `{ ... }`. just separate the initializations with commas. (https://en.cppreference.com/w/c/language/struct_initialization)",
      "revId": "6bd6a7c3e192ced17b51a4f2eeb2102f5031d45a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82468ee8_4798c647",
        "filename": "tests/utmp_test.cpp",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2023-01-25T19:27:34Z",
      "side": 1,
      "message": "I see. Sorry that I mess up unique pointer and stack-allocated variables. Our goal is to pass an address and the reference should be a stack-allocated variable. Using stack-allocated variables for safety and simplicity. The use of unique pointer is to help avoid forgetting dereference. But in this case, there is no need for unique pointer, just pass the address of the variable.",
      "parentUuid": "b7c7b776_39cbb778",
      "revId": "6bd6a7c3e192ced17b51a4f2eeb2102f5031d45a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49e55e4f_211d4fdb",
        "filename": "tests/utmp_test.cpp",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-01-25T20:15:32Z",
      "side": 1,
      "message": "unique_ptr is useful if you _have_ to allocate on the heap for some reason. two really common reasons for that:\n\n1. you\u0027re interacting with a legacy C API. you\u0027ll see a lot of unique_ptr usage with stdio FILE*s or similar API like opendir()/closedir(). random example: https://source.corp.google.com/android/packages/modules/adb/adb.cpp;l\u003d669?q\u003dfile:cpp%20unique_ptr%20release%20case:yes\u0026sq\u003dpackage:%5Eandroid$%20-file:prebuilts%2Fvndk%2F%20-file:prebuilts%2Fruntime%2F\n\n2. when there\u0027s one path through the function that calls .release(), and the unique_ptr is really just about cleaning up after any errors. random example: https://source.corp.google.com/android/frameworks/base/core/jni/android_content_res_ApkAssets.cpp;l\u003d442?q\u003dfile:cpp%20unique_ptr%20return.*release%5C(%5C)%20case:yes\u0026sq\u003dpackage:%5Eandroid$%20-file:prebuilts%2Fvndk%2F%20-file:prebuilts%2Fruntime%2F (especially because that has multiple error `return`s)\n\n\u003e The use of unique pointer is to help avoid forgetting dereference\n\n\"deallocation\" (aka \"free\"), yes.\n\n\u003e But in this case, there is no need for unique pointer, just pass the address of the variable.\n\nexactly: you don\u0027t have either of the problems mentioned above that usually motivate unique_ptr (and you don\u0027t have any other problem either :-) ) so you can just use the stack directly.",
      "parentUuid": "82468ee8_4798c647",
      "revId": "6bd6a7c3e192ced17b51a4f2eeb2102f5031d45a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5e4541c_a1afeef1",
        "filename": "tests/utmp_test.cpp",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2023-01-25T21:48:48Z",
      "side": 1,
      "message": "I see! Thank you :D",
      "parentUuid": "49e55e4f_211d4fdb",
      "revId": "6bd6a7c3e192ced17b51a4f2eeb2102f5031d45a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}