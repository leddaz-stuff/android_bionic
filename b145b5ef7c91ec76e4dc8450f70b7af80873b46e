{
  "comments": [
    {
      "key": {
        "uuid": "dcb1990e_78f7f8fc",
        "filename": "libc/dns/net/getaddrinfo.c",
        "patchSetId": 9
      },
      "lineNbr": 1932,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-03-17T15:31:33Z",
      "side": 0,
      "message": "Simply deleting the call to _using_default_dns without first putting proper routing in place may break apps that use startUsingNetworkFeature - they\u0027ll think they are on a secondary network and expect both IPv4 and IPv6 lookups to happen, but instead they\u0027ll just make lookups for the IP address families that the default interface has (because of our implementation of AI_ADDRCONFIG).\n\nOnce routing is in place this will start to work again, but is there something we can do about it in the meantime? Maybe have netd pass down a special \"unknown\" netid value that always causes both IPv4 and IPv6 lookups to happen?",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcb1990e_22bb76f0",
        "filename": "libc/dns/net/getaddrinfo.c",
        "patchSetId": 9
      },
      "lineNbr": 1932,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-03-18T07:00:42Z",
      "side": 0,
      "message": "Actually, we might be able to fix this by simply doing:\n\n    static bool _using_default_dns(unsigned netid) {\n        return netid \u003d\u003d NETID_UNSET;\n    }\n\n...\n\n    if (_using_default_dns(netid)) {\n        query_ipv6 \u003d _have_ipv6(netid);\n        query_ipv4 \u003d _have_ipv4(netid);\n    }\n\nThis will cause any code that sets the netid to cause superfluous DNS lookups (e.g., asking for AAAA records even if the netid doesn\u0027t have IPv6), but that\u0027s a lot better than not doing DNS lookups that might be required for things to work.",
      "parentUuid": "dcb1990e_78f7f8fc",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c2df129_f82f6da2",
        "filename": "libc/dns/net/getaddrinfo.c",
        "patchSetId": 9
      },
      "lineNbr": 1932,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-03-20T17:03:36Z",
      "side": 0,
      "message": "Three comments:\n1. Ironically _using_default_dns() will always return true at present because nobody passes a non-NULL iface down.  So in this regard removing _using_default_dns() is the correct thing to do, but this makes adding the netid parameter to _have_ipv[46]() incorrect as you note.\n2. Your _using_default_dns() suggestion unfortunately won\u0027t work because netid\u0027s set to NETID_UNSET will have been converted to the default netid back in netd, see:\n https://android-review.googlesource.com/#/c/87542/1/DnsProxyListener.cpp@211\n3. The manual page says configured addresses are checked on the \"local system\" while RFC2553 says configured source addresses on the \"node\" are checked.  We\u0027re kind of in a grey area because we\u0027re trying to do interface/netid-specific lookup.\n\nMy suggestion:\nWe get rid of _using_default_dns() because it didn\u0027t do anything in the past and we put _have_ipv[46]() back to the way they were (without netid param) so as not to mess with the old working behavior.\nWDYT?",
      "parentUuid": "dcb1990e_22bb76f0",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c2df129_f8420d7f",
        "filename": "libc/dns/net/getaddrinfo.c",
        "patchSetId": 9
      },
      "lineNbr": 1932,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-03-20T20:26:37Z",
      "side": 0,
      "message": "Oh wait, marking sockets doesn\u0027t do anything in AOSP to the best of my knowledge at the moment, so in this case I say leave the change as it stands now.",
      "parentUuid": "1c2df129_f82f6da2",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bcdf857e_b39de70a",
        "filename": "libc/dns/net/getaddrinfo.c",
        "patchSetId": 9
      },
      "lineNbr": 1932,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-03-24T15:32:29Z",
      "side": 0,
      "message": "1. Are you 100% sure it didn\u0027t do anything? IIRC _using_default_dns() was added because _have_ipv4 and_have_ipv6 check routing on the default interface rather than addresses. So the system would, for example, not request AAAA records on the IPv6-only IMS connection if the default conection was an IPv4-only wifi. See http://b/5468224 and internal change ID If4f017573d313a6ad8354574076de6d63d43b444 for more detail.\n\nI don\u0027t think that problem has gone away. Why do you say iface is always null? It\u0027s passed in with the mark by android_getaddrinfoforiface, right?\n\n3. I think the problem is not so much that we check routing even though the RFC says to check addresses, the problem is that we checking routing on the default network, and not necessarily on the network we\u0027re doing the DNS lookup on. I think routing is actually a reasonable proxy of what we want to do here.",
      "parentUuid": "1c2df129_f82f6da2",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c0d61ec_e2083cf8",
        "filename": "libc/dns/net/getaddrinfo.c",
        "patchSetId": 9
      },
      "lineNbr": 1932,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-03-24T21:28:58Z",
      "side": 0,
      "message": "Oops, I missed the tiny but very significant PID/UID override code in the DnsProxyListener... Duh.  Hmm, we could bring back the whole _resolv_set_default_iface interface, or how about this:\n1. We make DnsProxyListener pass the netId as:\n        netId \u003d\u003d mNetCtrl-\u003egetDefaultNetwork() ? NETID_UNSET : netId\n2. And make _using_default_dns() compare against NETID_UNSET like you proposed a couple comments back.\nWDYT?",
      "parentUuid": "bcdf857e_b39de70a",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcb49dfd_9932cc1d",
        "filename": "libc/dns/resolv/res_cache.c",
        "patchSetId": 9
      },
      "lineNbr": 1234,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2014-03-17T15:31:33Z",
      "side": 0,
      "message": "How do we deal with this now?",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c2df129_98e2f941",
        "filename": "libc/dns/resolv/res_cache.c",
        "patchSetId": 9
      },
      "lineNbr": 1234,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-03-20T17:03:36Z",
      "side": 0,
      "message": "I don\u0027t think we\u0027re changing behavior.  _resolv_cache_reset() was never called so |generation| was never set.  This is how resolv cache gets flushed before and after this change:\nConnectivityService calls\nmNetd.flushInterfaceDnsCache() sends\n\"resovler flushif\" to netd, calls\nCommandListener.cpp calls\nsResolverCtrl-\u003eflushInterfaceDnsCache() calls\n_resolv_flush_cache_for_iface() calls \n_flush_cache_for_iface_locked() calls \n_cache_flush_locked() who clears everything in the interface\u0027s cache while locking it.",
      "parentUuid": "fcb49dfd_9932cc1d",
      "revId": "b145b5ef7c91ec76e4dc8450f70b7af80873b46e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}