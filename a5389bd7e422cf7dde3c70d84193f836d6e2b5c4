{
  "comments": [
    {
      "key": {
        "uuid": "247f0a23_2c7ff3ff",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-12-12T18:56:40Z",
      "side": 1,
      "message": "Change the name of the test while you\u0027re at it. _SC_THREAD_KEYS_MAX_eq_PTHREAD_KEYS_MAX.",
      "range": {
        "startLine": 49,
        "startChar": 14,
        "endLine": 49,
        "endChar": 54
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "84eef632_ff229fc7",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2014-12-12T19:50:42Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "247f0a23_2c7ff3ff",
      "range": {
        "startLine": 49,
        "startChar": 14,
        "endLine": 49,
        "endChar": 54
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "247f0a23_ccac2f31",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-12-12T18:56:40Z",
      "side": 1,
      "message": "This should be EQ.",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 11
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "247f0a23_cfe181a7",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2014-12-12T19:50:42Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "247f0a23_ccac2f31",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 11
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04e04612_110eaca4",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-12-12T05:49:29Z",
      "side": 1,
      "message": "Isn\u0027t the bug here that sysconf is reporting the wrong number of keys? Or perhaps that pthread_key_create isn\u0027t failing as early as it\u0027s supposed to? man page says pthread_key_create fails after PTHREAD_KEYS_MAX keys have already been created, which is the case here if I understand the bug correctly.",
      "range": {
        "startLine": 89,
        "startChar": 83,
        "endLine": 89,
        "endChar": 93
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44a87ea2_86a15034",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2014-12-12T06:31:42Z",
      "side": 1,
      "message": "As far as I can see:\n1. sysconf(_SC_THREAD_KEYS_MAX) should return the system resource limit of maximum pthread_keys user can use. It should never change in the process lifetime. I think it means the low boundary more than the up boundary.\n2. for pthread_key_create, posix standard  said it shall fail EAGAIN if the system lacks necessary resource or system limit of THREAD_KEYS_MAX is exceeded.\n\nAfter doing test on glibc, I find sysconf(_SC_THREAD_KEYS_MAX) returns 1024 and user can create exactly 1024 pthread keys. Yes, that\u0027s the right behavior. \nBut our problem is some of our bionic source code is taking advantages of pthread_keys. For example, if you call gethostbyname, it will use one pthread key, I you don\u0027t call it, it will not use. So the real pthread keys that can be used by users is not a fix number.\n\nCurrently I have no good idea of how to handle this. Maybe just keep it as before. After all, almost all users will not complain about they can create more pthread keys than what system resource limit said.",
      "parentUuid": "04e04612_110eaca4",
      "range": {
        "startLine": 89,
        "startChar": 83,
        "endLine": 89,
        "endChar": 93
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "247f0a23_2cccd372",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-12-12T18:33:37Z",
      "side": 1,
      "message": "yes, sysconf results do tend to be the \"minimum maximum\".\n\nwe do try to account for the keys bionic can use internally though, and we have been trying to use __attribute__((constructor)) to make things more predictable (though this isn\u0027t free).\n\ni wonder if we should rewrite ThreadLocalBuffer.h to use one key that points to a struct that contains a pointer for each buffer? it would mean that we\u0027d have to have a central registry of all the thread local buffers, but that doesn\u0027t necessarily seem like a bad thing either.\n\nthe keys used by the DNS code are a bionic addition not in upstream, but even when you sync with upstream i think we\u0027ll want to keep that (because in bionic the non-_r functions try to be as safe as possible). there\u0027s a good argument that we shouldn\u0027t do this with the DNS functions but since we historically (\u003c\u003d L!) didn\u0027t have the full set of _r functions i don\u0027t think we can break the non-_r functions for multi-threaded use any time soon.\n\n\n\nbut right here right now, how about we say something like \"sysconf_max * 2\" to make it clear that we\u0027re deliberately just trying to allocate too much. (+10 seems like it might actually mean something, especially since we have roughly 10 internal-use keys.)",
      "parentUuid": "44a87ea2_86a15034",
      "range": {
        "startLine": 89,
        "startChar": 83,
        "endLine": 89,
        "endChar": 93
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6475823d_f1c1c261",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-12-12T18:56:40Z",
      "side": 1,
      "message": "\"..., or the system-imposed limit on the total number of keys per process {PTHREAD_KEYS_MAX} has been exceeded.\"\n\nSo, the test is actually right. We\u0027re allocating PTHREAD_KEYS_MAX and not failing with EAGAIN. If you look at ScopedTlsMapAccess::CreateKey(), we actually take the whole set into account, not just the ones that are user visible. That\u0027s the bug here.\n\nWe probably should still change the test to use PTHREAD_KEYS_MAX as the upper bound, to more explicitly test the POSIX defined behavior.",
      "parentUuid": "247f0a23_2cccd372",
      "range": {
        "startLine": 89,
        "startChar": 83,
        "endLine": 89,
        "endChar": 93
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e46a5265_6d3df1fe",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2014-12-12T19:50:42Z",
      "side": 1,
      "message": "\"To use one key points to a struct that contains a pointer for each buffer\", we may should know the size of the struct at compile time.",
      "parentUuid": "247f0a23_2cccd372",
      "range": {
        "startLine": 89,
        "startChar": 83,
        "endLine": 89,
        "endChar": 93
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "247f0a23_2f0e05a5",
        "filename": "tests/pthread_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2014-12-12T19:50:42Z",
      "side": 1,
      "message": "We have pthread.pthread_key_many_distinct to test how much pthread keys we can create, although it is relaxed. In this test, I think it is only to test pthread_key_create can return EAGAIN for error.\nI don\u0027t know whether PTHREAD_KEYS_MAX should be considered as the total pthread keys a process can create(both bionic and user and others). From the test of glibc, user can create exactly PTHREAD_KEY_MAX pthread keys(glibc may not use pthread keys in itself).",
      "parentUuid": "6475823d_f1c1c261",
      "range": {
        "startLine": 89,
        "startChar": 83,
        "endLine": 89,
        "endChar": 93
      },
      "revId": "a5389bd7e422cf7dde3c70d84193f836d6e2b5c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}