{
  "comments": [
    {
      "key": {
        "uuid": "fcce5d4a_80166630",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "suggestion: bool joinable;",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_201bf25a",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 69,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "\u003e did you actually have this problem? is that how you found the bugs in the original implementation?\n\nWe had an application with a library that \u0027suddenly\u0027 was using a SIGEV_THREAD timer for timeouts. That timer was deleted in a destructor, which was called when the child exited (using exit(), not _exit()). And that\u0027s where we got the deadlock in the old implementation.\n\nSince it happened based on a race, it was hard to reproduce and debug.\n\nSomething that would happily delete a timer that the new process has created could\u0027ve made the problem even harder to find.\n\nSo if it\u0027s possible to ensure that all inherited timer_t:s yield EINVAL without unreasonable cost, that\u0027d probably be a good idea. IMHO.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c348108_8aebcf5e",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 83,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Should you continue on all errors, or only if errno is EAGAIN or EINTR?",
      "range": {
        "startLine": 83,
        "startChar": 4,
        "endLine": 83,
        "endChar": 19
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c398d00_80a9f630",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 88,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "I think this means a timer fired with code SI_TIMER, correct? Or am I parsing this incorrectly?",
      "range": {
        "startLine": 88,
        "startChar": 44,
        "endLine": 88,
        "endChar": 48
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_3fe8ef20",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "I disagree with this interpretation of POSIX. I interpret it as saying that *user* can\u0027t join it, but that the user gets to choose which type of thread it will be.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_ffe90724",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "...so we should either pthread_join or do nothing here (depending on if the thread is JOINABLE or DETACHED).",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_5f005b1f",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "Worst-case scenario here, you\u0027ll be busy-looping for quite a while, even though the variable is volatile; some multi-core architectures have no guarantees for when a write is propagated from another node unless you\u0027re barrier:ing.",
      "parentUuid": "dccb593b_ffe90724",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c348108_ca4af79c",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 111,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Should errno be set to something here? Or is the assumption that malloc is doing that?",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 14
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c348108_4a3ee7f0",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 119,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Same as above, is __timer_create setting errno?",
      "range": {
        "startLine": 119,
        "startChar": 6,
        "endLine": 119,
        "endChar": 22
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_c1c31224",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 146,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "IMO, should use the default, or what the user specified. Store that (or a bool joinable), so that we know to join or not on delete.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_9f280398",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 146,
      "author": {
        "id": 1014443
      },
      "writtenOn": "2014-03-07T09:45:51Z",
      "side": 1,
      "message": "I don\u0027t understand why you\u0027re creating a detached thread to begin with. Looks like we\u0027re always going to wait for it to finish when the timer is deleted, which means we can free up after it. (Sure we don\u0027t immediately free up if someone manually sends a TKILL to the thread, but it\u0027s still an error not to call timer_delete to free up all resources associated with the timer, isn\u0027t it ?)",
      "parentUuid": "1cc2511e_c1c31224",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_40c4fe50",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 146,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T09:59:18Z",
      "side": 1,
      "message": "\u003e why you\u0027re creating a detached thread to begin with\n\nElliott interprets POSIX as saying it must be detached. I interpret POSIX as saying the user should be allowed to specify that it should be detached.\n\nI would also prefer to *not* wait for the thread to exit if it was created DETACHED. That way, the user\u0027s choice of JOINABLE/DETACHED is meaningful in timer_delete() ; JOINABLE would mean timer_delete() doesn\u0027t return until the thread is dead, while DETACHED would make no such guarantee.\n\n\u003e but it\u0027s still an error not to call timer_delete to free up all resources associated with the timer\n\nIt depends. A fork() child should *not* call timer_delete with inherited timer_t:s. With this implementation, that means we\u0027ll leak the inherited PosixTimer objects.",
      "parentUuid": "dccb593b_9f280398",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dca43989_82a42f58",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 179,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Is this safe to call if the thread terminates before this call happens?",
      "range": {
        "startLine": 179,
        "startChar": 2,
        "endLine": 179,
        "endChar": 55
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_6011fa38",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 199,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "How about just letting the thread free the timer instead?",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_bff37f0e",
        "filename": "tests/time_test.cpp",
        "patchSetId": 8
      },
      "lineNbr": 124,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "What happens if one of these asserts fail? I\u0027m guessing the assert throws some exception, which is caught in the runner... won\u0027t that mean that the child continues running the rest of the tests before exiting? Not a problem if it\u0027s still fast, I guess...",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_00227687",
        "filename": "tests/time_test.cpp",
        "patchSetId": 8
      },
      "lineNbr": 271,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "So here, the memory pointed to by timer_id has been freed. We can\u0027t be sure that it\u0027ll yield an EINVAL.\n\nOf course, we can\u0027t keep all old timer structs... so do we need a global list of valid pointers in timer.cpp? Or maybe checking a magic value in the struct -- zeroed before free -- would be good enough?\n\nI know we can\u0027t guard against all invalid timer_t:s, but it\u0027d be nice to catch most of them.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}