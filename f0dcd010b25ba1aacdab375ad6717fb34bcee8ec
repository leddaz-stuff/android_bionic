{
  "comments": [
    {
      "key": {
        "uuid": "fcce5d4a_80166630",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "suggestion: bool joinable;",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_201bf25a",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 69,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "\u003e did you actually have this problem? is that how you found the bugs in the original implementation?\n\nWe had an application with a library that \u0027suddenly\u0027 was using a SIGEV_THREAD timer for timeouts. That timer was deleted in a destructor, which was called when the child exited (using exit(), not _exit()). And that\u0027s where we got the deadlock in the old implementation.\n\nSince it happened based on a race, it was hard to reproduce and debug.\n\nSomething that would happily delete a timer that the new process has created could\u0027ve made the problem even harder to find.\n\nSo if it\u0027s possible to ensure that all inherited timer_t:s yield EINVAL without unreasonable cost, that\u0027d probably be a good idea. IMHO.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c348108_8aebcf5e",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 83,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Should you continue on all errors, or only if errno is EAGAIN or EINTR?",
      "range": {
        "startLine": 83,
        "startChar": 4,
        "endLine": 83,
        "endChar": 19
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c398d00_80a9f630",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 88,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "I think this means a timer fired with code SI_TIMER, correct? Or am I parsing this incorrectly?",
      "range": {
        "startLine": 88,
        "startChar": 44,
        "endLine": 88,
        "endChar": 48
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_3fe8ef20",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 102,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "I disagree with this interpretation of POSIX. I interpret it as saying that *user* can\u0027t join it, but that the user gets to choose which type of thread it will be.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_ffe90724",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "...so we should either pthread_join or do nothing here (depending on if the thread is JOINABLE or DETACHED).",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_5f005b1f",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "Worst-case scenario here, you\u0027ll be busy-looping for quite a while, even though the variable is volatile; some multi-core architectures have no guarantees for when a write is propagated from another node unless you\u0027re barrier:ing.",
      "parentUuid": "dccb593b_ffe90724",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c348108_ca4af79c",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 111,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Should errno be set to something here? Or is the assumption that malloc is doing that?",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 14
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c348108_4a3ee7f0",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 119,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Same as above, is __timer_create setting errno?",
      "range": {
        "startLine": 119,
        "startChar": 6,
        "endLine": 119,
        "endChar": 22
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_c1c31224",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 146,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "IMO, should use the default, or what the user specified. Store that (or a bool joinable), so that we know to join or not on delete.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dca43989_82a42f58",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 179,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2014-03-06T22:51:06Z",
      "side": 1,
      "message": "Is this safe to call if the thread terminates before this call happens?",
      "range": {
        "startLine": 179,
        "startChar": 2,
        "endLine": 179,
        "endChar": 55
      },
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_6011fa38",
        "filename": "libc/bionic/posix_timers.cpp",
        "patchSetId": 8
      },
      "lineNbr": 199,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:21:01Z",
      "side": 1,
      "message": "How about just letting the thread free the timer instead?",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_bff37f0e",
        "filename": "tests/time_test.cpp",
        "patchSetId": 8
      },
      "lineNbr": 124,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "What happens if one of these asserts fail? I\u0027m guessing the assert throws some exception, which is caught in the runner... won\u0027t that mean that the child continues running the rest of the tests before exiting? Not a problem if it\u0027s still fast, I guess...",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_00227687",
        "filename": "tests/time_test.cpp",
        "patchSetId": 8
      },
      "lineNbr": 271,
      "author": {
        "id": 1041495
      },
      "writtenOn": "2014-03-07T08:53:39Z",
      "side": 1,
      "message": "So here, the memory pointed to by timer_id has been freed. We can\u0027t be sure that it\u0027ll yield an EINVAL.\n\nOf course, we can\u0027t keep all old timer structs... so do we need a global list of valid pointers in timer.cpp? Or maybe checking a magic value in the struct -- zeroed before free -- would be good enough?\n\nI know we can\u0027t guard against all invalid timer_t:s, but it\u0027d be nice to catch most of them.",
      "revId": "f0dcd010b25ba1aacdab375ad6717fb34bcee8ec",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}