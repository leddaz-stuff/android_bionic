{
  "comments": [
    {
      "key": {
        "uuid": "8d1caf8e_9f2c96a9",
        "filename": "libc/bionic/bionic_elf_tls.cpp",
        "patchSetId": 9
      },
      "lineNbr": 187,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "__init_static_tls is called for each new thread. Shouldn\u0027t this be initialized once, when the modules are loaded?\n\nlinker_finalize_static_tls: At this point in a dynamic executable, all modules are static.\n\nlayout_static_tls: At this point in a static executable, there is either 0 or 1 static module. A static executable never has dynamic TLS modules.",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19659cdc_fdbbb993",
        "filename": "libc/bionic/bionic_elf_tls.cpp",
        "patchSetId": 9
      },
      "lineNbr": 187,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "I see. Thanks for the explanation!",
      "parentUuid": "8d1caf8e_9f2c96a9",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "98e08027_df91fc5a",
        "filename": "libc/bionic/bionic_elf_tls.cpp",
        "patchSetId": 9
      },
      "lineNbr": 406,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "I\u0027m confused. Do we really want to clear the callbacks when the first thread exits? The callbacks won\u0027t be called when the next thread exits?",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55050921_43438a8d",
        "filename": "libc/bionic/bionic_elf_tls.cpp",
        "patchSetId": 9
      },
      "lineNbr": 406,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "Good catch. I meant to free them when the *last* thread dies, but got confused.",
      "parentUuid": "98e08027_df91fc5a",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a71e538d_c9288e0a",
        "filename": "libc/bionic/pthread_exit.cpp",
        "patchSetId": 9
      },
      "lineNbr": 138,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "I think we also need to call __notify_thread_exit_callbacks in the THREAD_DETACHED case above (see the other call to __hwasan_thread_exit).\n\nI\u0027m wondering if the order w.r.t. __hwasan_thread_exit is right...",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a51382c4_6b531d6b",
        "filename": "libc/bionic/pthread_exit.cpp",
        "patchSetId": 9
      },
      "lineNbr": 138,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "Done. \n\nRe: ordering, yeah, these two definitely have conflicting goals in that both of them want to be called right before the thread is gone ... Perhaps to avoid breaking existing contract, the new callbacks should be called before hwasan_thread_exit() ?",
      "parentUuid": "a71e538d_c9288e0a",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f076e80b_522b16a9",
        "filename": "libc/bionic/sys_thread_properties.cpp",
        "patchSetId": 9
      },
      "lineNbr": 61,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "I wonder if we can just use malloc here. I assume we\u0027re not calling __libc_register_thread_exit_callback from a signal handler. Maybe it\u0027s hazardous to call malloc too early -- e.g. before libc.so\u0027s constructors have been called.\n\nIt looks like the first-vs-rest special case avoids the malloc call in the typical case where there\u0027s only 1 callback?",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa7f9528_1c72f000",
        "filename": "libc/bionic/sys_thread_properties.cpp",
        "patchSetId": 9
      },
      "lineNbr": 61,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "\u003e It looks like the first-vs-rest special case avoids the malloc call in the typical case where there\u0027s only 1 callback?\n\nYes, that\u0027s correct.",
      "parentUuid": "f076e80b_522b16a9",
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0a0e3c6_1c321f05",
        "filename": "libc/bionic/sys_thread_properties.cpp",
        "patchSetId": 9
      },
      "lineNbr": 112,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "Is this TODO message still correct? AFAIK, all the modules beyond the static modules are DTLS. (However, some of them may be unallocated, and I guess we don\u0027t want to call cb(nullptr, nullptr).)",
      "range": {
        "startLine": 112,
        "startChar": 5,
        "endLine": 112,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c565c3e0_a961b965",
        "filename": "libc/bionic/sys_thread_properties.cpp",
        "patchSetId": 9
      },
      "lineNbr": 112,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0a0e3c6_1c321f05",
      "range": {
        "startLine": 112,
        "startChar": 5,
        "endLine": 112,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22faff66_34495094",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "How do we know the target thread wasn\u0027t suspended during a DTLS modification?",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a41be5b3_721c6b4f",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "Sorry, I\u0027m not clear what you mean wrt \"DTLS modification\". \n\nThis \"suspended\" comment was meant to say \"If the DTLS is modified by the target thread while we are in this _iterate_ routine, then it\u0027s not guaranteed that the callback will be called on the newly touched DTLS\".\n\nThis _iterate_ does *not* modify anything.",
      "parentUuid": "22faff66_34495094",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17a35e29_9086d3de",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-17T05:08:04Z",
      "side": 1,
      "message": "\u003e This _iterate_ does *not* modify anything.\n\nRight, but what if a thread is suspended in update_tls_dtv while another thread is iterating its DTLS memory.\n\nI suspect we can make it work. This probably won\u0027t do what we want today:\n\n    allocator.free(dtv-\u003emodules[i]);\n    dtv-\u003emodules[i] \u003d nullptr;\n\ni.e. If the thread is suspended between these two calls, the DTLS memory is already freed, but the DTV still points at it. The iterate callback would report freed memory.\n\nCurrently, before any TLS memory is modified, the process blocks signals, then acquires a lock. The intent was to make DTLS async-signal-safe, but I neglected to handle the post-fork situation. Maybe in the future, the design should be changed to actually be async-signal-safe. The point, though, is that it\u0027s not normally possible to observe an intermediate state like the one above.\n\nIt might possible to observe this state in a debugger, but currently lldb/gdb don\u0027t have the metadata they need from libc.so to find TLS variables. A debugger should be robust against stray pointers into unallocated memory, too.",
      "parentUuid": "a41be5b3_721c6b4f",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55c78bba_d019dde6",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-17T17:14:28Z",
      "side": 1,
      "message": "Ah! I see what you mean.\n\nIn theory, this is problematic, but maybe in practice it\u0027s not too bad because IIUC, the sanitizers (which would call this _iterate_()) run at the end, which I think implies the program is not in the state where it\u0027s modifying stuff. (hence the \"undefined behaviour\" comment in the function\u0027s doc)",
      "parentUuid": "17a35e29_9086d3de",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8edc220_fb15df90",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-20T19:17:55Z",
      "side": 1,
      "message": "Btw, @rprichard, were you suggesting that we  must fix this issue in this patch?",
      "parentUuid": "55c78bba_d019dde6",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b477f8c_c8214836",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-20T23:14:59Z",
      "side": 1,
      "message": "\u003e ... run at the end\n\nDoes this mean that it runs when a program calls exit() or returns from main? I\u0027m not sure how processes typically end on Android, and I think a bunch of them practically run forever?\n\n\u003e Btw, @rprichard, were you suggesting that we  must fix this issue in this patch?\n\nIf we do need a fix, I think it can wait until later.",
      "parentUuid": "d8edc220_fb15df90",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1784fea_213a00dd",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-21T03:39:40Z",
      "side": 1,
      "message": "\u003e Does this mean that it runs when a program calls exit() or returns from main? \n\nIIUC, LSAN would call this in a frozen process; in dl-open, dl-close (and possibly when the thread is dying). \n\nThe dl-lock could also be grabbed before hand.\n\n\u003e I\u0027m not sure how processes typically end on Android, and I think a bunch of them practically run forever?\n\ntrue, in practice android programs don\u0027t exit?",
      "parentUuid": "2b477f8c_c8214836",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df326352_75795b52",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-22T22:47:17Z",
      "side": 1,
      "message": "Is LSAN using the library load/unload hook (load_hook) that HWASan also uses (e.g. __hwasan_library_loaded)?\n\nI think you\u0027d want the TLS lock (TlsModules::rwlock), not the loader lock? Currently, it would also be necessary to block signals first.",
      "parentUuid": "f1784fea_213a00dd",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2cd1b8b3_e39471a9",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-23T18:41:55Z",
      "side": 1,
      "message": "\u003e Is LSAN using the library load/unload hook (load_hook) that HWASan also uses (e.g. __hwasan_library_loaded)? \n\nA quick look at the code suggested it doesn\u0027t.\n\n\u003e I think you\u0027d want the TLS lock (TlsModules::rwlock), not the loader lock? Currently, it would also be necessary to block signals first.\n\nWould taking the TLS lock deadlock?\n\nWhen leak detection runs, it\u0027ll make a separate process (which shares the same address space with the main one), then freeze all the threads before doing the work(ie., calls this _iterate_ interface).\n\nWithout taking the lock, as you\u0027ve already pointed out, if the \"freeze\" happens just when a thread is in update_tls_dtv, then lsan would mistakenly scan freed memory. But this would probably be fine for the lsan use case. It\u0027s the other way around that is the problem (ie., if it can\u0027t find all the dtls regions, then it\u0027d have false positives).",
      "parentUuid": "df326352_75795b52",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c8bb949_43ba87ea",
        "filename": "libc/include/sys/thread_properties.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-08-04T16:16:35Z",
      "side": 1,
      "message": "@rprichard: friendly ping? Any thought/concern about this?\nThanks!",
      "parentUuid": "2cd1b8b3_e39471a9",
      "range": {
        "startLine": 73,
        "startChar": 3,
        "endLine": 73,
        "endChar": 40
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30af3095_30035854",
        "filename": "libc/private/bionic_elf_tls.h",
        "patchSetId": 9
      },
      "lineNbr": 163,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2020-07-16T07:44:40Z",
      "side": 1,
      "message": "Adding this field doubles the size of the DTV, which I think I\u0027d prefer to avoid. It should be possible to query the BionicAllocator to find the true size of the allocated heap chunk. (We would need to add an internal API to BionicAllocator.)",
      "range": {
        "startLine": 163,
        "startChar": 2,
        "endLine": 163,
        "endChar": 22
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7df4d7f6_af73a463",
        "filename": "libc/private/bionic_elf_tls.h",
        "patchSetId": 9
      },
      "lineNbr": 163,
      "author": {
        "id": 1631819
      },
      "writtenOn": "2020-07-16T21:15:16Z",
      "side": 1,
      "message": "Done. I\u0027ve added a `get_chunk_size`",
      "parentUuid": "30af3095_30035854",
      "range": {
        "startLine": 163,
        "startChar": 2,
        "endLine": 163,
        "endChar": 22
      },
      "revId": "c732ae3cc960c83ca8218f13ed0968e2b5e7d375",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}