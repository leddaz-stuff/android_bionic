From 744150bc76a3adebe71fd4e17d0c7321c909868d Mon Sep 17 00:00:00 2001
From: Kalesh Singh <kaleshsingh@google.com>
Date: Tue, 23 Jul 2024 14:24:48 -0700
Subject: [PATCH 19/20] Remove  debug prints

Change-Id: I75763a377a43e1902275995641df5e4e257f68fc
---
 linker/linker.cpp             | 10 -----
 linker/linker_main.cpp        |  2 -
 linker/linker_phdr.cpp        |  8 ----
 linker/linker_phdr_compat.cpp | 76 +++++++++++++++--------------------
 4 files changed, 32 insertions(+), 64 deletions(-)

diff --git a/linker/linker.cpp b/linker/linker.cpp
index 2e96d2dea..c02c88216 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -1692,12 +1692,9 @@ bool find_libraries(android_namespace_t* ns,
   for (auto&& task : load_list) {
     address_space_params* address_space =
         (reserved_address_recursive || !task->is_dt_needed()) ? &extinfo_params : &default_params;
-    DL_ERR_LOADER_TEST("find_libraries: Loading %s", task->get_soinfo()->get_soname());
     if (!task->load(address_space)) {
-      DL_ERR_LOADER_TEST("find_libraries: Loading %s failed", task->get_soinfo()->get_soname());
       return false;
     } else {
-      DL_ERR_LOADER_TEST("find_libraries: Loading %s success", task->get_soinfo()->get_soname());
     }
   }
 
@@ -1705,7 +1702,6 @@ bool find_libraries(android_namespace_t* ns,
   bool any_memtag_stack = false;
   for (auto&& task : load_tasks) {
     soinfo* si = task->get_soinfo();
-    DL_ERR_LOADER_TEST("find_libraries: Prelinking %s", si->get_soname());
     if (!si->is_linked() && !si->prelink_image()) {
       return false;
     }
@@ -2842,27 +2838,22 @@ bool relocate_relr(const ElfW(Relr)* begin, const ElfW(Relr)* end, ElfW(Addr) lo
 static soinfo_list_t g_empty_list;
 
 bool soinfo::prelink_image() {
-  DL_ERR_LOADER_TEST("%s: prelink_image: start", get_soname());
   if (flags_ & FLAG_PRELINKED) return true;
   /* Extract dynamic section */
-  DL_ERR_LOADER_TEST("%s: prelink_image: load_bias = %p", get_soname(), reinterpret_cast<void*>(load_bias));
   ElfW(Word) dynamic_flags = 0;
   phdr_table_get_dynamic_section(phdr, phnum, load_bias, &dynamic, &dynamic_flags);
-  DL_ERR_LOADER_TEST("prelink_image: dynamic_flags = %p, dynamic = %p", reinterpret_cast<void*>(dynamic_flags), reinterpret_cast<void*>(dynamic));
 
   /* We can't log anything until the linker is relocated */
   bool relocating_linker = (flags_ & FLAG_LINKER) != 0;
   if (!relocating_linker) {
     INFO("[ Linking \"%s\" ]", get_realpath());
     DEBUG("si->base = %p si->flags = 0x%08x", reinterpret_cast<void*>(base), flags_);
-    DL_ERR_LOADER_TEST("prelink_image: !relocating_linker");
   }
 
   if (dynamic == nullptr) {
     if (!relocating_linker) {
       DL_ERR("missing PT_DYNAMIC in \"%s\"", get_realpath());
     }
-    DL_ERR_LOADER_TEST("prelink_image: dynamic == nullptr");
     return false;
   } else {
     if (!relocating_linker) {
@@ -2875,7 +2866,6 @@ bool soinfo::prelink_image() {
                                   &ARM_exidx, &ARM_exidx_count);
 #endif
 
-  DL_ERR_LOADER_TEST("prelink_image: Doing TLS stuff now");
   TlsSegment tls_segment;
   if (__bionic_get_tls_segment(phdr, phnum, load_bias, &tls_segment)) {
     // The loader does not (currently) support ELF TLS, so it shouldn't have
diff --git a/linker/linker_main.cpp b/linker/linker_main.cpp
index fccc1ea6a..cd270dfcb 100644
--- a/linker/linker_main.cpp
+++ b/linker/linker_main.cpp
@@ -296,8 +296,6 @@ static ExecutableInfo load_executable(const char* orig_path) {
   result.should_pad_segments = elf_reader.should_pad_segments();
   result.load_bias = elf_reader.load_bias();
 
-  DL_ERR_LOADER_TEST("ExecInfo::load_bias = %p", result.load_bias);
-
   return result;
 }
 
diff --git a/linker/linker_phdr.cpp b/linker/linker_phdr.cpp
index 4bb15b1ea..26578d9d1 100644
--- a/linker/linker_phdr.cpp
+++ b/linker/linker_phdr.cpp
@@ -1396,20 +1396,15 @@ int phdr_table_get_arm_exidx(const ElfW(Phdr)* phdr_table, size_t phdr_count,
 void phdr_table_get_dynamic_section(const ElfW(Phdr)* phdr_table, size_t phdr_count,
                                     ElfW(Addr) load_bias, ElfW(Dyn)** dynamic,
                                     ElfW(Word)* dynamic_flags) {
-  DL_ERR_LOADER_TEST("phdr_table_get_dynamic_section: load_bias = %p", reinterpret_cast<void*>(load_bias));
   *dynamic = nullptr;
   for (size_t i = 0; i<phdr_count; ++i) {
-    DL_ERR_LOADER_TEST("phdr_table_get_dynamic_section: phdr # %zu", i);
     const ElfW(Phdr)& phdr = phdr_table[i];
     if (phdr.p_type == PT_DYNAMIC) {
-      DL_ERR_LOADER_TEST("phdr_table_get_dynamic_section: found dynamic section: vaddr = %p", reinterpret_cast<void*>(phdr.p_vaddr));
       *dynamic = reinterpret_cast<ElfW(Dyn)*>(load_bias + phdr.p_vaddr);
       if (dynamic_flags) {
         *dynamic_flags = phdr.p_flags;
       }
       return;
-    } else {
-      DL_ERR_LOADER_TEST("phdr_table_get_dynamic_section: section is not dynamic: vaddr = %p", reinterpret_cast<void*>(phdr.p_vaddr));
     }
   }
 }
@@ -1440,11 +1435,9 @@ const char* phdr_table_get_interpreter_name(const ElfW(Phdr)* phdr_table, size_t
 bool ElfReader::FindPhdr() {
   const ElfW(Phdr)* phdr_limit = phdr_table_ + phdr_num_;
 
-  DL_ERR_LOADER_TEST("%s: FindPhdr: Start", name_.c_str());
   // If there is a PT_PHDR, use it directly.
   for (const ElfW(Phdr)* phdr = phdr_table_; phdr < phdr_limit; ++phdr) {
     if (phdr->p_type == PT_PHDR) {
-      DL_ERR_LOADER_TEST("%s: FindPhdr: Found phdr segment: at %p", name_.c_str(), reinterpret_cast<void*>(load_bias_ + phdr->p_vaddr));
       return CheckPhdr(load_bias_ + phdr->p_vaddr);
     }
   }
@@ -1458,7 +1451,6 @@ bool ElfReader::FindPhdr() {
         ElfW(Addr)  elf_addr = load_bias_ + phdr->p_vaddr;
         const ElfW(Ehdr)* ehdr = reinterpret_cast<const ElfW(Ehdr)*>(elf_addr);
         ElfW(Addr)  offset = ehdr->e_phoff;
-      DL_ERR_LOADER_TEST("%s: FindPhdr: Assume phdr in first loadable segment at %p", name_.c_str(), reinterpret_cast<void*>(reinterpret_cast<ElfW(Addr)>(ehdr) + offset));
         return CheckPhdr(reinterpret_cast<ElfW(Addr)>(ehdr) + offset);
       }
       break;
diff --git a/linker/linker_phdr_compat.cpp b/linker/linker_phdr_compat.cpp
index eb4d00bce..031fad443 100644
--- a/linker/linker_phdr_compat.cpp
+++ b/linker/linker_phdr_compat.cpp
@@ -40,8 +40,17 @@
 #include <sys/mman.h>
 
 static const size_t kPageSize = page_size();
+
 static constexpr size_t kCompatPageSize = 4096;
 
+static inline uintptr_t page_start_compat(uintptr_t x) {
+  return x & ~(kCompatPageSize - 1);
+}
+
+static inline uintptr_t page_end_compat(uintptr_t x) {
+  return page_start_compat(x + kCompatPageSize - 1);
+}
+
 bool loader_4kb_compat_enabled() {
   return true;
 }
@@ -68,19 +77,11 @@ ElfW(Addr) min_palign(const ElfW(Phdr)* phdr_table, size_t phdr_count) {
   return min_align;
 }
 
-static inline uintptr_t page_start_compat(uintptr_t x) {
-  return x & ~(kCompatPageSize - 1);
-}
-
-static inline uintptr_t page_end_compat(uintptr_t x) {
-  return page_start_compat(x + kCompatPageSize - 1);
-}
-
-inline bool has_relro_prefix(const ElfW(Phdr)* phdr, const ElfW(Phdr)* relro) {
+static inline bool has_relro_prefix(const ElfW(Phdr)* phdr, const ElfW(Phdr)* relro) {
     return relro && phdr->p_type == PT_LOAD && phdr->p_vaddr == relro->p_vaddr;
 }
 
-const ElfW(Phdr)* relro_segment(const ElfW(Phdr)* phdr_table, size_t phdr_count) {
+static const ElfW(Phdr)* relro_segment(const ElfW(Phdr)* phdr_table, size_t phdr_count) {
   for (size_t i = 0; i < phdr_count; ++i) {
     const ElfW(Phdr)* phdr = &phdr_table[i];
 
@@ -97,7 +98,7 @@ const ElfW(Phdr)* relro_segment(const ElfW(Phdr)* phdr_table, size_t phdr_count)
  *
  * Returns true if successful (there is only 1 such boundary), and false otherwise.
  */
-bool rx_rw_vaddr(const ElfW(Phdr)* phdr_table, size_t phdr_count, ElfW(Addr) *vaddr, const char *name) {
+static bool rx_rw_boundary_vaddr(const ElfW(Phdr)* phdr_table, size_t phdr_count, ElfW(Addr) *vaddr, const char *name) {
   const ElfW(Phdr)* relro_phdr = relro_segment(phdr_table, phdr_count);
   ElfW(Phdr)* last_rw = nullptr;
   ElfW(Phdr)* first_rw = nullptr;
@@ -142,7 +143,7 @@ bool rx_rw_vaddr(const ElfW(Phdr)* phdr_table, size_t phdr_count, ElfW(Addr) *va
   return true;
 }
 
-ElfW(Addr) perm_boundary_offset(const ElfW(Addr) vaddr) {
+static ElfW(Addr) perm_boundary_offset(const ElfW(Addr) vaddr) {
   ElfW(Addr) offset = page_offset(vaddr);
 
   return offset ? page_size() - page_offset(vaddr) : 0;
@@ -157,39 +158,32 @@ int phdr_table_protect_gnu_relro_compat(ElfW(Addr) start, ElfW(Addr) size) {
 }
 
 bool ElfReader::LoadSegments4kbCompat() {
-  DL_ERR_LOADER_TEST("%s: LoadSegments4kbCompat: start", name_.c_str());
   ElfW(Addr) perm_boundary_vaddr;
 
-  if (!rx_rw_vaddr(phdr_table_, phdr_num_, &perm_boundary_vaddr, name_.c_str())) {
+  if (!rx_rw_boundary_vaddr(phdr_table_, phdr_num_, &perm_boundary_vaddr, name_.c_str())) {
     return false;
   }
 
-  ElfW(Addr) perm_offset = perm_boundary_offset(perm_boundary_vaddr);
-
-  ElfW(Addr) load_bias = load_bias_ + perm_offset;
-  DL_ERR_LOADER_TEST("%s: load_bias_ old = %p, load_bias new = %p", name_.c_str(), reinterpret_cast<void*>(load_bias_), reinterpret_cast<void*>(load_bias));
+  // Adjust the load_bias to position the RX|RW boundary on a page boundary
+  load_bias_ += perm_boundary_offset(perm_boundary_vaddr);
 
   // Make .data ... .bss region RW only (not X)
-  ElfW(Addr) rw_start = load_bias + perm_boundary_vaddr;
+  ElfW(Addr) rw_start = load_bias_ + perm_boundary_vaddr;
   ElfW(Addr) rw_size = load_size_ - (rw_start - reinterpret_cast<ElfW(Addr)>(load_start_));
 
-  if (rw_start % kPageSize) {
-    DL_ERR("\"%s\" rw_start (%p) is not page aligned", name_.c_str(), reinterpret_cast<void*>(rw_start));
-    return false;
-  }
+  CHECK(rw_start % kPageSize == 0);
+  CHECK(rw_size % kPageSize == 0);
 
-  if (rw_size % kPageSize) {
-    DL_ERR("\"%s\" rw_size (%p) is not page aligned", name_.c_str(), reinterpret_cast<void*>(rw_size));
-    return false;
-  }
+  // Label the RW portion of the mapping
+  prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, rw_start, rw_size,
+        std::string(name_ + " (compat loaded [.data ... .bss])").c_str());
 
-  // Save the compat RELRO (.text .... .relro) section limits
+  // Save the compat RELRO (.text ... .data.relro) section limits
   compat_relro_start_ = reinterpret_cast<ElfW(Addr)>(load_start_);
   compat_relro_size_ = load_size_ - rw_size;
 
-  std::string rw_name = name_ + " (compat loaded RW)";
-  prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, rw_start, rw_size, rw_name.c_str());
-
+  // NOTE: The legacy page size (4096) must be used when aligning the legacy segments for loading (reading).
+  // The larger 16kB page size will lead to overwriting adjacent segments due to larger-page alignment.
   for (size_t i = 0; i < phdr_num_; ++i) {
     const ElfW(Phdr)* phdr = &phdr_table_[i];
 
@@ -198,7 +192,7 @@ bool ElfReader::LoadSegments4kbCompat() {
     }
 
     // Segment addresses in memory.
-    ElfW(Addr) seg_start = phdr->p_vaddr + load_bias;
+    ElfW(Addr) seg_start = phdr->p_vaddr + load_bias_;
     ElfW(Addr) seg_end = seg_start + phdr->p_memsz;
 
     ElfW(Addr) seg_page_start = page_start_compat(seg_start);
@@ -243,12 +237,12 @@ bool ElfReader::LoadSegments4kbCompat() {
       }
 
       if (lseek(fd_, file_offset_ + file_page_start, SEEK_SET) == -1) {
-        DL_ERR_AND_LOG("\"%s\" failed lseek: %m", name_.c_str());
+        DL_ERR_AND_LOG("\"%s\" failed lseek LOAD segment %zu: %m", name_.c_str(), i);
         return false;
       }
 
       if (read(fd_, reinterpret_cast<void*>(seg_page_start), file_length) == -1) {
-        DL_ERR_AND_LOG("\"%s\" failed lseek: %m", name_.c_str());
+        DL_ERR_AND_LOG("\"%s\" failed read LOAD segment %zu: %m", name_.c_str(), i);
         return false;
       }
     }
@@ -260,18 +254,12 @@ bool ElfReader::LoadSegments4kbCompat() {
     seg_file_end = page_end_compat(seg_file_end);
 
     // NOTE: We do not need to handle .bss since the mapping reservation is
-    // anonymous and RW.
+    // anonymous and RW to begin with.
 
-    // Label the compat mapping
-    std::string compat_name = name_ + " (compat loaded)";
-    prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, load_start_, load_size_ - rw_size, compat_name.c_str());
+    // Label the RW compat mapping
+    prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, load_start_, load_size_ - rw_size,
+          std::string(name_ + " (compat loaded [.text ... .data.relro])").c_str());
   }
 
-  memset(reinterpret_cast<void*>(load_bias_), 0, load_bias - load_bias_);
-
-  // TODO: revisit this
-  load_bias_ = load_bias;
-
-  DL_ERR_LOADER_TEST("%s: LoadSegments4kbCompat: end", name_.c_str());
   return true;
 }
-- 
2.45.2.1089.g2a221341d9-goog

