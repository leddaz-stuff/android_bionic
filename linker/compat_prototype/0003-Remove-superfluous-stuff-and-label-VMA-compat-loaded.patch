From 9e2f0853ec72c5f1e00531f254a2bf3a40189ec1 Mon Sep 17 00:00:00 2001
From: Kalesh Singh <kaleshsingh@google.com>
Date: Thu, 18 Jul 2024 14:31:15 -0700
Subject: [PATCH 03/20] Remove superfluous stuff and label VMA (compat loaded)

Change-Id: I0a4e6cf57a0e612783aaf1df88bcdb24ce4ce563
---
 linker/linker_phdr_compat.cpp | 76 +++++------------------------------
 1 file changed, 10 insertions(+), 66 deletions(-)

diff --git a/linker/linker_phdr_compat.cpp b/linker/linker_phdr_compat.cpp
index 1e954974e..9ed3f6228 100644
--- a/linker/linker_phdr_compat.cpp
+++ b/linker/linker_phdr_compat.cpp
@@ -122,78 +122,22 @@ bool ElfReader::LoadSegments4kbCompat() {
         add_dlwarning(name_.c_str(), "W+E load segments");
       }
 
-      if (phdr->p_align < kPageSize && loader_4kb_compat_enabled()) {
-        lseek(fd_, file_offset_ + file_page_start, SEEK_SET);
-        read(fd_, reinterpret_cast<void*>(seg_page_start), file_length);
-      } else {
-        void* seg_addr = mmap64(reinterpret_cast<void*>(seg_page_start),
-                              file_length,
-                              prot,
-                              MAP_FIXED|MAP_PRIVATE,
-                              fd_,
-                              file_offset_ + file_page_start);
-        if (seg_addr == MAP_FAILED) {
-          DL_ERR("couldn't map \"%s\" segment %zd: %s", name_.c_str(), i, strerror(errno));
-          return false;
-        }
-      }
-    }
-
-    // if the segment is writable, and does not end on a page boundary,
-    // zero-fill it until the page limit.
-    //
-    // Do not attempt to zero the extended region past the first partial page,
-    // since doing so may:
-    //   1) Result in a SIGBUS, as the region is not backed by the underlying
-    //      file.
-    //   2) Break the COW backing, faulting in new anon pages for a region
-    //      that will not be used.
-
-    uint64_t unextended_seg_file_end = seg_start + phdr->p_filesz;
-    if ((phdr->p_flags & PF_W) != 0 && page_offset(unextended_seg_file_end) > 0) {
-      memset(reinterpret_cast<void*>(unextended_seg_file_end), 0,
-             kPageSize - page_offset(unextended_seg_file_end));
+      lseek(fd_, file_offset_ + file_page_start, SEEK_SET);
+      read(fd_, reinterpret_cast<void*>(seg_page_start), file_length);
     }
 
-    // Pages may be brought in due to readahead.
-    // Drop the padding (zero) pages, to avoid reclaim work later.
-    //
-    // NOTE: The madvise() here is special, as it also serves to hint to the
-    // kernel the portion of the LOAD segment that is padding.
-    //
-    // See: [1] https://android-review.googlesource.com/c/kernel/common/+/3032411
-    //      [2] https://android-review.googlesource.com/c/kernel/common/+/3048835
-    uint64_t pad_start = page_end(unextended_seg_file_end);
-    uint64_t pad_end = page_end(seg_file_end);
-    CHECK(pad_start <= pad_end);
-    uint64_t pad_len = pad_end - pad_start;
-    if (page_size_migration_supported() && pad_len > 0 &&
-        madvise(reinterpret_cast<void*>(pad_start), pad_len, MADV_DONTNEED)) {
-      DL_WARN("\"%s\": madvise(0x%" PRIx64 ", 0x%" PRIx64 ", MADV_DONTNEED) failed: %m",
-              name_.c_str(), pad_start, pad_len);
-    }
+    // NOTE: if the segment is writable, and does not end on a page boundary,
+    // usually need to zero-fill it until the page limit; however in this case the
+    // mapping is anonymous, so it is not needed.
 
     seg_file_end = page_end(seg_file_end);
 
-    // seg_file_end is now the first page address after the file
-    // content. If seg_end is larger, we need to zero anything
-    // between them. This is done by using a private anonymous
-    // map for all extra pages.
-    if (seg_page_end > seg_file_end) {
-      size_t zeromap_size = seg_page_end - seg_file_end;
-      void* zeromap = mmap(reinterpret_cast<void*>(seg_file_end),
-                           zeromap_size,
-                           PFLAGS_TO_PROT(phdr->p_flags),
-                           MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,
-                           -1,
-                           0);
-      if (zeromap == MAP_FAILED) {
-        DL_ERR("couldn't zero fill \"%s\" gap: %s", name_.c_str(), strerror(errno));
-        return false;
-      }
+    // NOTE: We do not need to handle .bss since the mapping reservation is 
+    // anonymous and RW.
 
-      prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, zeromap, zeromap_size, ".bss");
-    }
+    // Label the compat mapping
+    std::string compat_name = name_ + " (compat loaded)";
+    prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, load_start_, load_size_, compat_name.c_str());
   }
   return true;
 }
-- 
2.45.2.1089.g2a221341d9-goog

