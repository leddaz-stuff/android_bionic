{
  "comments": [
    {
      "key": {
        "uuid": "02a8435a_c4f6be93",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 9
      },
      "lineNbr": 92,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-26T00:19:55Z",
      "side": 1,
      "message": "Is this necessary?\n\nThe logic I had in mind was:\n\n0. Keep the data structure as it originally was around revision 6.\n\n1. Check that this threads copy of the data is non-null and associated with the correct sequence number.  If not, we\u0027re done.\n\n2) Check that the data is not null (without reading the destructor).  If it\u0027s null we\u0027re done.\n\n3) [Slight revision of my prior reasoning, sorry.]  At this\npoint we know thread local data was updated by this thread.\nEither that update raced with the key_create() call, which\nI think we should declare illegal (and I presume Posix would if they had their act together), or the key_create call \"happened before\" this code is being called.  Thus it is now safe to read the destructor field.  Read it using a non-atomic access, and invoke the destructor if appropriate.\n\nThe only dubious case is if the theoretical case in which the above race was somehow prevented using memory_order_consume without introducing a happens-before ordering for us.  This would only be an issue if we had a compiler that didn\u0027t implement consume as acquire.  We don\u0027t, and we\u0027re not likely to anytime soon.  I wouldn\u0027t worry about it beyond documenting the assumption.",
      "range": {
        "startLine": 91,
        "startChar": 10,
        "endLine": 92,
        "endChar": 84
      },
      "revId": "9c500ab2083e5dd0a5ceeef0b99fb04646750214",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42431b81_9e083da4",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 9
      },
      "lineNbr": 92,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-26T01:02:50Z",
      "side": 1,
      "message": "This is the scenario that forces me to use two release-acquire fences:\nThread1\nthread_key_create(\u0026key1, destructor1);\nthread_key_delete(key1);\nthread_key_create(\u0026key2, NULL);\ncreate thread2, and let it uses and finishes using key2, which can be done by reference counter or others,\nbut thread2 is not joined.\nthread_key_delete(key2);\nthread_key_create(\u0026key3, destructor3);\nthread_key_delete(key3);\n\nThread2\nIt uses and finishes using key2, having a non-null data.\nThen it comes to pthread_key_clean_all()\nAs we use memory_order_relaxed to read seq, it is possible that we read the old seq number of key2,\nbut read destructor3, so we take the risk of calling destructor3(non-null data for key2).\n\nI can\u0027t see any place in this scenario is ileagal in standard.",
      "parentUuid": "02a8435a_c4f6be93",
      "range": {
        "startLine": 91,
        "startChar": 10,
        "endLine": 92,
        "endChar": 84
      },
      "revId": "9c500ab2083e5dd0a5ceeef0b99fb04646750214",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c26aab65_2ae4bfa8",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 9
      },
      "lineNbr": 92,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-26T23:41:50Z",
      "side": 1,
      "message": "Yes, good catch.  You do need to reread the sequence number in order, and the destructor field needs to be atomic.\n\nI don\u0027t immediately see why you need the HAS_DESTRUCTOR bit, or why you need the first re-load of seq.  By my argument, since we saw non-null data with the right sequence number, the appropriate key_create must already have happened before us.  Thus the destructor store for this seq must have happened before us.  Thus we can\u0027t see an earlier destructor.  The fact that we saw seq unchanged after reading the destructor, which is only rewritten after updating seq, seems to imply that we can\u0027t see a later one, modulo comments below.",
      "parentUuid": "42431b81_9e083da4",
      "range": {
        "startLine": 91,
        "startChar": 10,
        "endLine": 92,
        "endChar": 84
      },
      "revId": "9c500ab2083e5dd0a5ceeef0b99fb04646750214",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22f0e70e_1dbdd3ac",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 9
      },
      "lineNbr": 92,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-27T00:28:14Z",
      "side": 1,
      "message": "We always don\u0027t need to worry about using an earlier destructor. It is user\u0027s responsibility to forbidden that.\nYeah, in current implementation, we don\u0027t set key_destructor to NULL in pthread_key_create for performance reason, but we use SEQ_HAS_DESTRUCTOR_BIT to take care of it.",
      "parentUuid": "c26aab65_2ae4bfa8",
      "range": {
        "startLine": 91,
        "startChar": 10,
        "endLine": 92,
        "endChar": 84
      },
      "revId": "9c500ab2083e5dd0a5ceeef0b99fb04646750214",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c26aab65_6a32b768",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 9
      },
      "lineNbr": 151,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-26T23:41:50Z",
      "side": 1,
      "message": "The ordering here is too weak.  If a slot is reused by two different otherwise unrelated threads, and both use a destructor, there is nothing to enforce ordering between the two destructor stores.  Thus any subsequent observer can see either.",
      "range": {
        "startLine": 151,
        "startChar": 60,
        "endLine": 151,
        "endChar": 81
      },
      "revId": "9c500ab2083e5dd0a5ceeef0b99fb04646750214",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5ad55fe_521474ba",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 9
      },
      "lineNbr": 151,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-27T00:28:14Z",
      "side": 1,
      "message": "We only have destructor store in pthread_key_create, which is protected by key_map[key].seq. Only thread taking owner of key slot can store destructor. Am I missing your point?",
      "parentUuid": "c26aab65_6a32b768",
      "range": {
        "startLine": 151,
        "startChar": 60,
        "endLine": 151,
        "endChar": 81
      },
      "revId": "9c500ab2083e5dd0a5ceeef0b99fb04646750214",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}