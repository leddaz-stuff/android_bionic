{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "18d43d24_91679007",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2024-07-30T18:20:31Z",
      "side": 1,
      "message": "There are build failures, but I don\u0027t think they are related to this change.",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fbaa7eeb_b5fa02bf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-07-30T19:34:39Z",
      "side": 1,
      "message": "no, they seem legit:\n```\nld.lld: error: undefined symbol: strerrorname_np\n```\nfor values of \"legit\" that include \"we said don\u0027t call this unless you\u0027re building for a high enough target api level, but you called it and then complained it wouldn\u0027t link\".\n\ni think we were getting away with this before because the macro name was wrong, so the condition was always false, so we never compiled this path. but i don\u0027t understand _why_ we seem to have a target api vs linked-against-libraries discrepancy here...\n\nthough it\u0027s probably something to do with\n```\n-target aarch64-linux-android10000\n```\nand/or the many mentions of \"vendor\" here.\n\n+ccross?",
      "parentUuid": "18d43d24_91679007",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f04f0f74_e727cfff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2024-07-31T05:33:12Z",
      "side": 1,
      "message": "The failing build is the vendor variant.  It is linking against the vendor variant of libc, which is stubs built from `out/soong/.intermediates/bionic/libc/libc/android_vendor_arm64_armv8-a_cortex-a53_shared/gen/stub.map`.  That file doesn\u0027t mention `strerrorname_np`, but the non-vendor stubs do.  The vendor stubs are built with `--api 202504`, which seems to come from the `BOARD_API_LEVEL` value.",
      "parentUuid": "fbaa7eeb_b5fa02bf",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "422fc39f_1c794b46",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-07-31T18:40:28Z",
      "side": 1,
      "message": "+jiyong for whether that\u0027s expected, or another artifact of \"35 isn\u0027t in AOSP yet\". (i\u0027m surprised that\u0027s 202*five*04, not 202*four*04? surely _next year\u0027s_ abi should include this year\u0027s abi?)",
      "parentUuid": "f04f0f74_e727cfff",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4254afa5_d6ae2f98",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-07-31T23:18:02Z",
      "side": 1,
      "message": "BOARD_API_LEVEL being 202504 is as expected for the trunk_staging release config because 202404 was already released and trunk_staging is future facing.\n\nWhat\u0027s not expected is the absence of strerrorname_np in the vendor-side stub.\n\nCan you try again after experimentally adding (not replacing the existing one) `strerrorname_np; # llndk\u003d202504` (or `llndk\u003d202404`) to the map.txt file? That may reveal what went wrong.\n\ncc: @justinyun@google.com",
      "parentUuid": "422fc39f_1c794b46",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7e28bd8_1ab8188d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1146974
      },
      "writtenOn": "2024-08-01T01:26:17Z",
      "side": 1,
      "message": "Since API level 35, symbols are not added to LLNDK automatically. They must be explicitly tagged with `llndk\u003d\u003cvendor api level\u003e` as Jiyong commented. See aosp/2997316 and this doc: https://docs.google.com/document/d/1r7H3fWQfPmIBPgREhpNAImGbK1mVXm3PpxNCE9h-Z6g/edit?resourcekey\u003d0-A3r_kSp8feBDLVthm2uy6g\u0026tab\u003dt.0#heading\u003dh.wke4uaif5p5z",
      "parentUuid": "4254afa5_d6ae2f98",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df666c7f_18873fca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-01T12:18:47Z",
      "side": 1,
      "message": "surely that\u0027s a bug for libc/libm/libdl though? why would we ever _not_ want libc symbols in the NDK but not LLNDK?",
      "parentUuid": "d7e28bd8_1ab8188d",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21186cfa_18228288",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-05T17:48:04Z",
      "side": 1,
      "message": "+danalbert: were you aware of this?\n\nllndk team: what\u0027s the way forward here? us having to track your llndk versions doesn\u0027t seem realistic, and we\u0027re just going to end up with more messes like this where something that\u0027s in 35 can now presumably never be in whatever the corresponding llndk was?",
      "parentUuid": "df666c7f_18873fca",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a073c89_2423ebf8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2024-08-05T21:23:30Z",
      "side": 1,
      "message": "Vaguely. I don\u0027t remember this part though:\n\n\u003e Since API level 35, symbols are not added to LLNDK automatically\n\nWhy not? The doc says that\u0027s what happened, but it doesn\u0027t say why.",
      "parentUuid": "21186cfa_18228288",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a6b1277_3d72c39f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1146974
      },
      "writtenOn": "2024-08-05T23:32:55Z",
      "side": 1,
      "message": "The reason was the different finalization schedule for API level 35 and 202404.\nEven though the LLNDK 202404 was finalized in Q2, API 35 still can be changed until it is finalized in Q3.\nTo mitigate the problem, we may explicitly tag the newly added symbols after the vFRC by adding the symbols before the finalization automatically to the finalized LLNDK. @jooyung@google.com WDYT?",
      "parentUuid": "4a073c89_2423ebf8",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7b2ea62_8e2b13ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-13T13:49:09Z",
      "side": 1,
      "message": "jooyung: what\u0027s the plan here? it isn\u0027t realistic to expect us to annotate every single bionic symbol, and i\u0027m assuming it\u0027s not _intentional_ for the llndk to just \"stop\" at api 34?",
      "parentUuid": "5a6b1277_3d72c39f",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27fe4488_6c4083d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2024-08-15T03:18:50Z",
      "side": 1,
      "message": "(Sorry for late responding) I don\u0027t have any plan on this. I think we agreed upon the idea of explicit tagging for LLNDK symbols starting from 202404. If this doesn\u0027t work for you, I think we can fix it. I have no better idea yet. Any suggestion?",
      "parentUuid": "f7b2ea62_8e2b13ef",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1343e25_ca6a0449",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-15T20:52:38Z",
      "side": 1,
      "message": "\u003e (Sorry for late responding)\n\nno worries --- kbs made it seem like everyone else had the day off, so i hope you did too :-)\n\n\u003e Any suggestion?\n\ni\u0027ll admit i\u0027ve never really understood llndk (other than the \"it\u0027s a subset\" part), _especially_ for bionic. given that bionic\u0027s compatibility guarantee is _stronger_ than any vendor guarantee, and there\u0027s no separate \"vendor libc\", i feel like bionic\u0027s involvement here is just a historical accident?\n\nso my first suggestion would be: can we just say \"all of bionic\"? our api/abi comes from gnu/posix/linux anyway, so it\u0027s not like we change anything during development.\n\nmy second alternative: if you really want to be behind, why not just have your tools lag by one api level? (which i think jiyong was implying is what _should_ have happened? that the vendor stub should already include strerrorname_np() because it\u0027s an api 35 api, and so by definition must be in any llndk later than that?)\n\n(a quick codesearch shows that only libbinder and libcgroups have llndk\u003d lines, and that seems fair enough [to me as someone who doesn\u0027t add api to either] --- they\u0027re not in the ndk, they don\u0027t conform to any external standard, and they do change over time. and presumably (?) they only need to add the llndk\u003d lines if they actually need to expose their stuff to vendors, and having that default \"off\" for those libraries sounds reasonable to me. but not for libc!)",
      "parentUuid": "27fe4488_6c4083d1",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ac03eb4_2680f8c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-08-16T06:14:14Z",
      "side": 1,
      "message": "libbinder_ndk *is* NDK, though libcgrouprc isn\u0027t.\n\n`llndk\u003d` in the map file is actually a good thing. It gives you an explicit control over what to expose to the vendor world, and *when*.\n\nI know; in the context of bionic, there\u0027s little to no reason to hide an NDK symbol to vendors. So, having to add `llndk\u003d` to all new NDK symbols may be considered a duplicated effort. Bug given that the number of NDK symbols added yearly is quite small (~10 - ~20), I guess it\u0027s not a really big burden (please correct me here). If needed, we can take that effort.\n\nWe (Treble team) have always wanted to decouple ourselves from the yearly release of the API surface for app developers. \"35 isn\u0027t in AOSP yet\" is one good example of kind of situations we\u0027d like to avoid. LLNDK neither is for app developers nor has to be release yearly in sync with the Android SDK release.",
      "parentUuid": "c1343e25_ca6a0449",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e263ffd_32a97d34",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-16T13:48:41Z",
      "side": 1,
      "message": "\u003e If needed, we can take that effort.\n\nit\u0027s not just that i don\u0027t want to do this work (though, no, i don\u0027t), i also don\u0027t want the map filled with this cruft. it\u0027s not as bad as polluting the headers, but it\u0027s still useless noise that makes it harder for people to answer the [far more important, to far more people] questions of \"when did \u003cfoo\u003e appear?\" or \"what\u0027s in \u003cactual api level\u003e?\".\n\n\u003e We (Treble team) have always wanted to decouple ourselves from the yearly release of the API surface for app developers. \"35 isn\u0027t in AOSP yet\" is one good example of kind of situations we\u0027d like to avoid.\n\nyes, but \"we\" (bionic team) are already decoupled for changes that don\u0027t need a new OS by virtue of the \"real NDK\", and decoupling for changes that _do_ need a new OS makes no sense.\n\nand we\u0027re _always_ in AOSP :-)\n\n\u003e LLNDK neither is for app developers nor has to be release yearly in sync with the Android SDK release.\n\nthis is the bit i don\u0027t understand --- what _exactly_ is the goal here, specifically with respect to bionic? what is 202404 (say) supposed to correspond to? my argument (for the bionic team\u0027s sanity) is that it should be _exactly_ 35. (basically: \"your vendor thing should just be floor(our current thing)\"; there\u0027s no advantage to us of having another variant of bionic to support. vendors should always just be on the last \"real NDK\" release, and if they don\u0027t like that, well, they should reconsider why exactly they\u0027re asking to be treated differently from the rest of the platform, and whether it makes sense for the specific case of bionic[1].)\n\nright now it seems like we\u0027ve created extra work, extra duplicate boilerplate cruft, and all for no real-world positive impact on anyone?\n\n____\n1. i actually have no opinion about this either way --- i _suspect_ it\u0027s a waste of time, because _behavioral_ differences are 100x more likely than ABI changes, but \"meh, they\u0027re only hurting themselves, and generally not much, because they probably also don\u0027t have a new enough kernel/don\u0027t care about the latest C23 stuff/etc\".",
      "parentUuid": "5ac03eb4_2680f8c6",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8239801c_83f222b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-08-16T14:30:53Z",
      "side": 1,
      "message": "\u003e what exactly is the goal here, specifically with respect to bionic?\n\nThe goal here is to provide an API surface for (SoC) vendors which can be released independently from the Android SDK release cycle.\n\nIn other words, we want that vendors don\u0027t have to deal with the API levels (35, 36, ...) which basically is for app developers. Since the beginning of Treble, vendors do not build against NDK/SDK, but we implicitly extended the meaning of API levels to version something that is not NDK/SDK and became to have its own release schedule with trunk stable; we think this was a big mistake.  \n\nTherefore, YYYYMM (ex: 202404) is supposed to be a new version scheme (that is completely independent from the existing API level) that vendors use to identify the set of APIs available for them. VSR (vendor software requirement) is already written in terms of YYYYMM.",
      "parentUuid": "8e263ffd_32a97d34",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4176ee1_5d28d075",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2024-08-16T20:14:46Z",
      "side": 1,
      "message": "If this actually decoupled it\u0027d be one thing, but it doesn\u0027t, right? There\u0027 isn\u0027t a separate vendor libc.so, is there? The library exposes NDK symbols to the LL-NDK regardless of what the map file says about the LL-NDK. What\u0027s the benefit to hiding (at build time) NDK symbols from the LL-NDK?\n\n\u003e basically: \"your vendor thing should just be floor(our current thing)\"; there\u0027s no advantage to us of having another variant of bionic to support. vendors should always just be on the last \"real NDK\" release\n\n+1. I thought this was the plan. I\u0027m really not keen on having this defined per API domain.",
      "parentUuid": "8239801c_83f222b7",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}