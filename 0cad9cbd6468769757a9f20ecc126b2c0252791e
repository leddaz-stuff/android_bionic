{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "18d43d24_91679007",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2024-07-30T18:20:31Z",
      "side": 1,
      "message": "There are build failures, but I don\u0027t think they are related to this change.",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fbaa7eeb_b5fa02bf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-07-30T19:34:39Z",
      "side": 1,
      "message": "no, they seem legit:\n```\nld.lld: error: undefined symbol: strerrorname_np\n```\nfor values of \"legit\" that include \"we said don\u0027t call this unless you\u0027re building for a high enough target api level, but you called it and then complained it wouldn\u0027t link\".\n\ni think we were getting away with this before because the macro name was wrong, so the condition was always false, so we never compiled this path. but i don\u0027t understand _why_ we seem to have a target api vs linked-against-libraries discrepancy here...\n\nthough it\u0027s probably something to do with\n```\n-target aarch64-linux-android10000\n```\nand/or the many mentions of \"vendor\" here.\n\n+ccross?",
      "parentUuid": "18d43d24_91679007",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f04f0f74_e727cfff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2024-07-31T05:33:12Z",
      "side": 1,
      "message": "The failing build is the vendor variant.  It is linking against the vendor variant of libc, which is stubs built from `out/soong/.intermediates/bionic/libc/libc/android_vendor_arm64_armv8-a_cortex-a53_shared/gen/stub.map`.  That file doesn\u0027t mention `strerrorname_np`, but the non-vendor stubs do.  The vendor stubs are built with `--api 202504`, which seems to come from the `BOARD_API_LEVEL` value.",
      "parentUuid": "fbaa7eeb_b5fa02bf",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "422fc39f_1c794b46",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-07-31T18:40:28Z",
      "side": 1,
      "message": "+jiyong for whether that\u0027s expected, or another artifact of \"35 isn\u0027t in AOSP yet\". (i\u0027m surprised that\u0027s 202*five*04, not 202*four*04? surely _next year\u0027s_ abi should include this year\u0027s abi?)",
      "parentUuid": "f04f0f74_e727cfff",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4254afa5_d6ae2f98",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-07-31T23:18:02Z",
      "side": 1,
      "message": "BOARD_API_LEVEL being 202504 is as expected for the trunk_staging release config because 202404 was already released and trunk_staging is future facing.\n\nWhat\u0027s not expected is the absence of strerrorname_np in the vendor-side stub.\n\nCan you try again after experimentally adding (not replacing the existing one) `strerrorname_np; # llndk\u003d202504` (or `llndk\u003d202404`) to the map.txt file? That may reveal what went wrong.\n\ncc: @justinyun@google.com",
      "parentUuid": "422fc39f_1c794b46",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7e28bd8_1ab8188d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1146974
      },
      "writtenOn": "2024-08-01T01:26:17Z",
      "side": 1,
      "message": "Since API level 35, symbols are not added to LLNDK automatically. They must be explicitly tagged with `llndk\u003d\u003cvendor api level\u003e` as Jiyong commented. See aosp/2997316 and this doc: https://docs.google.com/document/d/1r7H3fWQfPmIBPgREhpNAImGbK1mVXm3PpxNCE9h-Z6g/edit?resourcekey\u003d0-A3r_kSp8feBDLVthm2uy6g\u0026tab\u003dt.0#heading\u003dh.wke4uaif5p5z",
      "parentUuid": "4254afa5_d6ae2f98",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df666c7f_18873fca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-01T12:18:47Z",
      "side": 1,
      "message": "surely that\u0027s a bug for libc/libm/libdl though? why would we ever _not_ want libc symbols in the NDK but not LLNDK?",
      "parentUuid": "d7e28bd8_1ab8188d",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21186cfa_18228288",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-05T17:48:04Z",
      "side": 1,
      "message": "+danalbert: were you aware of this?\n\nllndk team: what\u0027s the way forward here? us having to track your llndk versions doesn\u0027t seem realistic, and we\u0027re just going to end up with more messes like this where something that\u0027s in 35 can now presumably never be in whatever the corresponding llndk was?",
      "parentUuid": "df666c7f_18873fca",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a073c89_2423ebf8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2024-08-05T21:23:30Z",
      "side": 1,
      "message": "Vaguely. I don\u0027t remember this part though:\n\n\u003e Since API level 35, symbols are not added to LLNDK automatically\n\nWhy not? The doc says that\u0027s what happened, but it doesn\u0027t say why.",
      "parentUuid": "21186cfa_18228288",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a6b1277_3d72c39f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1146974
      },
      "writtenOn": "2024-08-05T23:32:55Z",
      "side": 1,
      "message": "The reason was the different finalization schedule for API level 35 and 202404.\nEven though the LLNDK 202404 was finalized in Q2, API 35 still can be changed until it is finalized in Q3.\nTo mitigate the problem, we may explicitly tag the newly added symbols after the vFRC by adding the symbols before the finalization automatically to the finalized LLNDK. @jooyung@google.com WDYT?",
      "parentUuid": "4a073c89_2423ebf8",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7b2ea62_8e2b13ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-13T13:49:09Z",
      "side": 1,
      "message": "jooyung: what\u0027s the plan here? it isn\u0027t realistic to expect us to annotate every single bionic symbol, and i\u0027m assuming it\u0027s not _intentional_ for the llndk to just \"stop\" at api 34?",
      "parentUuid": "5a6b1277_3d72c39f",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27fe4488_6c4083d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2024-08-15T03:18:50Z",
      "side": 1,
      "message": "(Sorry for late responding) I don\u0027t have any plan on this. I think we agreed upon the idea of explicit tagging for LLNDK symbols starting from 202404. If this doesn\u0027t work for you, I think we can fix it. I have no better idea yet. Any suggestion?",
      "parentUuid": "f7b2ea62_8e2b13ef",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1343e25_ca6a0449",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-15T20:52:38Z",
      "side": 1,
      "message": "\u003e (Sorry for late responding)\n\nno worries --- kbs made it seem like everyone else had the day off, so i hope you did too :-)\n\n\u003e Any suggestion?\n\ni\u0027ll admit i\u0027ve never really understood llndk (other than the \"it\u0027s a subset\" part), _especially_ for bionic. given that bionic\u0027s compatibility guarantee is _stronger_ than any vendor guarantee, and there\u0027s no separate \"vendor libc\", i feel like bionic\u0027s involvement here is just a historical accident?\n\nso my first suggestion would be: can we just say \"all of bionic\"? our api/abi comes from gnu/posix/linux anyway, so it\u0027s not like we change anything during development.\n\nmy second alternative: if you really want to be behind, why not just have your tools lag by one api level? (which i think jiyong was implying is what _should_ have happened? that the vendor stub should already include strerrorname_np() because it\u0027s an api 35 api, and so by definition must be in any llndk later than that?)\n\n(a quick codesearch shows that only libbinder and libcgroups have llndk\u003d lines, and that seems fair enough [to me as someone who doesn\u0027t add api to either] --- they\u0027re not in the ndk, they don\u0027t conform to any external standard, and they do change over time. and presumably (?) they only need to add the llndk\u003d lines if they actually need to expose their stuff to vendors, and having that default \"off\" for those libraries sounds reasonable to me. but not for libc!)",
      "parentUuid": "27fe4488_6c4083d1",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ac03eb4_2680f8c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-08-16T06:14:14Z",
      "side": 1,
      "message": "libbinder_ndk *is* NDK, though libcgrouprc isn\u0027t.\n\n`llndk\u003d` in the map file is actually a good thing. It gives you an explicit control over what to expose to the vendor world, and *when*.\n\nI know; in the context of bionic, there\u0027s little to no reason to hide an NDK symbol to vendors. So, having to add `llndk\u003d` to all new NDK symbols may be considered a duplicated effort. Bug given that the number of NDK symbols added yearly is quite small (~10 - ~20), I guess it\u0027s not a really big burden (please correct me here). If needed, we can take that effort.\n\nWe (Treble team) have always wanted to decouple ourselves from the yearly release of the API surface for app developers. \"35 isn\u0027t in AOSP yet\" is one good example of kind of situations we\u0027d like to avoid. LLNDK neither is for app developers nor has to be release yearly in sync with the Android SDK release.",
      "parentUuid": "c1343e25_ca6a0449",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e263ffd_32a97d34",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-16T13:48:41Z",
      "side": 1,
      "message": "\u003e If needed, we can take that effort.\n\nit\u0027s not just that i don\u0027t want to do this work (though, no, i don\u0027t), i also don\u0027t want the map filled with this cruft. it\u0027s not as bad as polluting the headers, but it\u0027s still useless noise that makes it harder for people to answer the [far more important, to far more people] questions of \"when did \u003cfoo\u003e appear?\" or \"what\u0027s in \u003cactual api level\u003e?\".\n\n\u003e We (Treble team) have always wanted to decouple ourselves from the yearly release of the API surface for app developers. \"35 isn\u0027t in AOSP yet\" is one good example of kind of situations we\u0027d like to avoid.\n\nyes, but \"we\" (bionic team) are already decoupled for changes that don\u0027t need a new OS by virtue of the \"real NDK\", and decoupling for changes that _do_ need a new OS makes no sense.\n\nand we\u0027re _always_ in AOSP :-)\n\n\u003e LLNDK neither is for app developers nor has to be release yearly in sync with the Android SDK release.\n\nthis is the bit i don\u0027t understand --- what _exactly_ is the goal here, specifically with respect to bionic? what is 202404 (say) supposed to correspond to? my argument (for the bionic team\u0027s sanity) is that it should be _exactly_ 35. (basically: \"your vendor thing should just be floor(our current thing)\"; there\u0027s no advantage to us of having another variant of bionic to support. vendors should always just be on the last \"real NDK\" release, and if they don\u0027t like that, well, they should reconsider why exactly they\u0027re asking to be treated differently from the rest of the platform, and whether it makes sense for the specific case of bionic[1].)\n\nright now it seems like we\u0027ve created extra work, extra duplicate boilerplate cruft, and all for no real-world positive impact on anyone?\n\n____\n1. i actually have no opinion about this either way --- i _suspect_ it\u0027s a waste of time, because _behavioral_ differences are 100x more likely than ABI changes, but \"meh, they\u0027re only hurting themselves, and generally not much, because they probably also don\u0027t have a new enough kernel/don\u0027t care about the latest C23 stuff/etc\".",
      "parentUuid": "5ac03eb4_2680f8c6",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8239801c_83f222b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-08-16T14:30:53Z",
      "side": 1,
      "message": "\u003e what exactly is the goal here, specifically with respect to bionic?\n\nThe goal here is to provide an API surface for (SoC) vendors which can be released independently from the Android SDK release cycle.\n\nIn other words, we want that vendors don\u0027t have to deal with the API levels (35, 36, ...) which basically is for app developers. Since the beginning of Treble, vendors do not build against NDK/SDK, but we implicitly extended the meaning of API levels to version something that is not NDK/SDK and became to have its own release schedule with trunk stable; we think this was a big mistake.  \n\nTherefore, YYYYMM (ex: 202404) is supposed to be a new version scheme (that is completely independent from the existing API level) that vendors use to identify the set of APIs available for them. VSR (vendor software requirement) is already written in terms of YYYYMM.",
      "parentUuid": "8e263ffd_32a97d34",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4176ee1_5d28d075",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2024-08-16T20:14:46Z",
      "side": 1,
      "message": "If this actually decoupled it\u0027d be one thing, but it doesn\u0027t, right? There\u0027 isn\u0027t a separate vendor libc.so, is there? The library exposes NDK symbols to the LL-NDK regardless of what the map file says about the LL-NDK. What\u0027s the benefit to hiding (at build time) NDK symbols from the LL-NDK?\n\n\u003e basically: \"your vendor thing should just be floor(our current thing)\"; there\u0027s no advantage to us of having another variant of bionic to support. vendors should always just be on the last \"real NDK\" release\n\n+1. I thought this was the plan. I\u0027m really not keen on having this defined per API domain.",
      "parentUuid": "8239801c_83f222b7",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60b9fd72_7c4e8e9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-16T20:33:37Z",
      "side": 1,
      "message": "\u003e There\u0027 isn\u0027t a separate vendor libc.so, is there?\n\nexactly --- that\u0027s the \"this makes no sense, we\u0027re just making life difficult/confusing for ourselves\" point for me...",
      "parentUuid": "d4176ee1_5d28d075",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f561268e_3cc91d6d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2024-08-16T22:14:03Z",
      "side": 1,
      "message": "\u003e . What\u0027s the benefit to hiding (at build time) NDK symbols from the LL-NDK?\n\nIt\u0027s about API freezing. We want vendor-available symbols to be frozen when NDK symbols are still not frozen.\n\nAnd last time I pointed out V symbols won\u0027t be available to vendor, Elliott, you mentioned that \"they didn\u0027t have them last year, so i don\u0027t see why they\u0027d have to have them this year\" ðŸ˜Š (in aosp/2994436)\n\n\n\u003e \"your vendor thing should just be floor(our current thing)\"\n\nI think this sounds good and IMO this is exactly what we want to do for now. Btw it seems like we don\u0027t agree on how we do it. Would it be hard \"no\" to tag #llndk\u003dyyyymm for those new symbols?",
      "parentUuid": "60b9fd72_7c4e8e9a",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e4d853a_76e01c46",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1146974
      },
      "writtenOn": "2024-08-18T23:58:53Z",
      "side": 1,
      "message": "\u003e There\u0027 isn\u0027t a separate vendor libc.so, is there? The library exposes NDK symbols to the LL-NDK regardless of what the map file says about the LL-NDK.\n\nNo, there isn\u0027t a separate vendor libc.so, but there is a separate stub file for the vendor libc.so to be used on build time. The vendor FRC is to freeze those vendor exposed symbols before they are frozen for the NDK. This means some symbols can be frozen earlier than the SDK API finalization if they are marked as LLNDK symbols.",
      "parentUuid": "f561268e_3cc91d6d",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d5978c5_d3f365a4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-08-19T08:23:53Z",
      "side": 1,
      "message": "+1 to both jooyung and justin. thanks.",
      "parentUuid": "2e4d853a_76e01c46",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c36d756_730ccbbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-19T12:29:30Z",
      "side": 1,
      "message": "\u003e And last time I pointed out V symbols won\u0027t be available to vendor, Elliott, you mentioned that \"they didn\u0027t have them last year, so i don\u0027t see why they\u0027d have to have them this year\" ðŸ˜Š (in aosp/2994436)\n\nbut this is *25* that\u0027s causing trouble, no? 25 should V? and since 25 won\u0027t have \"W\", you should be able to fill out 25 with V right now?\n\n\u003e I think this sounds good and IMO this is exactly what we want to do for now. Btw it seems like we don\u0027t agree on how we do it. Would it be hard \"no\" to tag #llndk\u003dyyyymm for those new symbols?\n\nyes, we shouldn\u0027t be crufting up anything maintained by humans with machine-generated boilerplate (where only one possible thing is correct, and everything else would be a mistake!).\n\n\u003e No, there isn\u0027t a separate vendor libc.so, but there is a separate stub file for the vendor libc.so to be used on build time. The vendor FRC is to freeze those vendor exposed symbols before they are frozen for the NDK. This means some symbols can be frozen earlier than the SDK API finalization if they are marked as LLNDK symbols.\n\n(to be clear: i still don\u0027t understand _why_ --- this just makes no sense to me. what purpose does pretending that these things don\u0027t exist actually serve?)",
      "parentUuid": "7d5978c5_d3f365a4",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86e48d0c_05ebda19",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1146974
      },
      "writtenOn": "2024-08-19T13:14:36Z",
      "side": 1,
      "message": "\u003e what purpose does pretending that these things don\u0027t exist actually serve?\n\nNo, we are not pretending, but they actually did not exist when finalizing the LLNDK.\n\nAssume we are finalizing the LLNDK `libfoo` with 202504. `libfoo` has only a single symbol `foo_A` that was added in early 2025. So the `foo_A` is not in NDK for V, but used from a vendor module for 202504.\nAs vendor modules are using the `foo_A` it must not be modified even before the NDK for W is finalized. That is why we need to have a separate versioning for each symbol that cannot use the NDK versioning.\nThe `foo_A` will be finalized again for NDK-W along with some more symbols added after the vendor finalization.\n\nAs discussed before, we may have used a single versioning that bumps for both vendor and SDK finalizations. But that was not agreed. (go/vfrc-llndk-versioning)",
      "parentUuid": "8c36d756_730ccbbe",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ac9558d_c1916eac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2024-08-19T14:29:09Z",
      "side": 1,
      "message": "\u003e No, we are not pretending, but they actually did not exist when finalizing the LLNDK.\n\n...but they do exist when the code is built/run, so \"who cares?\".\n\ni\u0027m not asking philosophical questions here, i\u0027m asking the completely practical question \"why does this matter?\". (though it might help to read the bit below first, about app compat, which is _why_ i think this philosophical distinction isn\u0027t helpful.)\n\n\u003e Assume we are finalizing the LLNDK libfoo with 202504. libfoo has only a single symbol foo_A that was added in early 2025. So the foo_A is not in NDK for V, but used from a vendor module for 202504.\n\nthis is not the case i\u0027m talking about, in several ways:\n\n1. i\u0027m claiming that \"libfoo\" and \"libc/libm/libdl\" are not comparable. i have no argument with (or, strictly, \"no interest in\") the \"libfoo\" case. i\u0027m claiming that the bionic libraries _specifically_ are a special case with _much stronger_ compatibility guarantees because they have to maintain _app_ compatibility.\n\n2. if a symbol is in V, it must be in 2025+, right? since V is 202*4*\u0027s api level, and 2025\u003e2024.\n\nso for bionic it seems like #1 warrants a special case, and #2 tells us the lower bound of what that special case is. (like i said, i don\u0027t actually care about the -- to me nonsensical -- \"wait a year for something that\u0027s already there\" issue that causes me to say \"the lower bound of what\" rather than just \"what\". my only interest is that we\u0027re not holding them back _indefinitely_, because that would be silly.)",
      "parentUuid": "86e48d0c_05ebda19",
      "revId": "0cad9cbd6468769757a9f20ecc126b2c0252791e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}