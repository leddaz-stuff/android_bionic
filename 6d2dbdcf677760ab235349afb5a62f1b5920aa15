{
  "comments": [
    {
      "key": {
        "uuid": "168ca173_2dbd99ed",
        "filename": "libc/include/android/versioning.h",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-09-14T22:54:55Z",
      "side": 1,
      "message": "I think this should still be APEX specific. The platform\u0027s NDK behavior shouldn\u0027t be different since it just makes it easier to forget the guard and break NDK users. This would be exceptionally easy to do since the compiler is going to tell the user to do the wrong thing.\n\nAs an example, I add `foo()` to S but forget to add the guard, so clang thinks it\u0027s introduced in 10000. In CTS I call `foo()`, and clang tells me that I need to wrap it in `__builtin_available()`. That\u0027s the wrong advice for the test author. What they need to do is add the missing guard. Getting this right would be entirely up to the reviewer, and getting it wrong would not be noticed until an NDK user tries to call the API.\n\nThe build break you pointed out in the other change (https://android-build.googleplex.com/builds/pending/P16535749/aosp_crosshatch-userdebug/latest/view/logs/build_error.log) is actually broken and does need to be fixed if that code is supposed to work pre API 30.",
      "revId": "6d2dbdcf677760ab235349afb5a62f1b5920aa15",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb3e872c_c1b50c6d",
        "filename": "libc/include/android/versioning.h",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-09-15T03:41:11Z",
      "side": 1,
      "message": "What\u0027s the \u0027guard\u0027 you are referring to? Does it mean __INTRODUCED_IN(api_level)? If so, forgetting to annotating foo() with the macro won\u0027t cause any compilation error because the symbol is then assumed to be there from the beginning (i.e. api level 0). So, there won\u0027t be a wrong advice here.\n\nThis nevertheless is a problem because the symbol should anyway be annotated. I wonder how you have enforced every Bionic symbols to be annotated with the __INTRODUCED_IN macro. \n\n\u003e does need to be fixed if that code is supposed to work pre API 30\n\nI think ag/1425365 should be the fix, but the \u0027strict\u0027 option is preventing the API 30 symbols from being used at all when min_sdk_version is \u003c 30 - even with __builtin_available checks.",
      "parentUuid": "168ca173_2dbd99ed",
      "revId": "6d2dbdcf677760ab235349afb5a62f1b5920aa15",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cfc19462_386aa4ca",
        "filename": "libc/include/android/versioning.h",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-09-15T21:02:35Z",
      "side": 1,
      "message": "Oh, duh. Had that backward. Honestly I\u0027m just impressed that in a full day of post-vacation email I only said one stupid thing :)\n\nThe build break above still points out how this would make it easier to write bugs in the NDK though, right? That case is a header that is in the NDK that refers to a function that\u0027s being called without a guard. The obvious fix if we allow the platform to be non-strict is to use `__builtin_available` to guard it, I think. That would break the NDK though, since that\u0027s still strict. The code that caused that build break needs to use dlsym to be compatible with anyone using strict availability, right? Or have I misunderstood the breakage?\n\nEven if we do end up making the non-strict mode an option in the future we\u0027d keep strict around because it\u0027s the only safe default.\n\nBut if we can\u0027t use this anywhere we\u0027ll never be able to figure out if it works or not, so maybe it actually is best to just ship this as an option (with a giant disclaimer) for the NDK. That way it can be off by default for the platform but the modules that don\u0027t ship *code* in the NDK can opt-in. How about:\n\n```\n// Enabling ANDROID_UNSTABLE_WEAK_AVAILABILITY causes any NDK APIs that\n// aren\u0027t available in the minSdkVersion of the OS to be weak symbols.\n// This means that code can refer to these symbols so long as it is\n// careful to not call unavailable APIs without checking for them, rather\n// than needing to use dlsym. Calling an API that is not available on the\n// device will result in a crash. It is strongly recommended to set\n// `-Werror\u003dunguarded-availability` in any build that uses this feature.\n//\n// Note that source compatibility is *not* guaranteed when this feature\n// is enabled. This feature is a preview. New NDKs may require changes to\n// how APIs are used, or how their existence is checked, or remove this\n// feature entirely.\n//\n// Also note that this does not make it possible to use APIs of\n// *libraries* that do not exist in the minSdkVersion of the OS. Those\n// still require dlopen/dlsym as there is no such thing as a weak library\n// dependency.\n//\n// Library authors should not use this feature in public headers. Relying\n// on this behavior in code that is inline in headers will force the\n// decision on your users.\n#if defined(ANDROID_UNSTABLE_PREVIEW_WEAK_AVAILABILITY)\n#define __MAYBE_STRICT\n#else\n#define __MAYBE_STRICT ,strict\n#endif\n```\n\nAnd then adding `weak_ndk_apis: true|false` for soong modules (so I only have to update soong when we change the name and not every module)? I don\u0027t think we know enough about this feature to know if it will even be source stable yet, so a foreboding name seems like a good idea.\n\nI\u0027ll run this past the rest of the team in the bionic meeting on Wednesday.",
      "parentUuid": "bb3e872c_c1b50c6d",
      "revId": "6d2dbdcf677760ab235349afb5a62f1b5920aa15",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d8985eb_350e95a6",
        "filename": "libc/include/android/versioning.h",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-09-16T11:39:53Z",
      "side": 1,
      "message": "binder_parcel_utils.h is a bad example because it actually has to be out of NDK. See aosp/1356964. Nevertheless, yes, you are right, we might have similar cases in other legit headers. That\u0027s a good point.\n\nI thought we could omit \u0027strict\u0027 as long as we process NDK headers with the versioner. The ifdef guards added by the tool has the same effect as \u0027strict\u0027.\n\nIf we are going to deprecate the versioner anytime soon, then yes, `strict` should be used for NDK clients given that we can\u0027t enforce them to be compiling with \u0027-Wunguarded-availability -Werror\u0027 (or can we?). \n\nI think what you suggested makes a lot of sense. I however think we don\u0027t need the fancy Soong switch because the module can use \u0027cflags: [\"-DANDROID_UNSTABLE...\"]\u0027 instead. In addition, not shipping the code to NDK is a big limitation at least for binder_parcel_utils.h, which unfortunately is available to NDK clients.\n\nYour idea actually inspired me to think this simple (albeit a little bit dirty) alternative. Let\u0027s keep \u0027strict\u0027 for all non-APEX cases as you originally suggested. Inside binder_parcel_utils.h, the symbols are re-declared now without the \u0027strict\u0027 flag just before it is used. So, \n\n// in binder_parcel_utils.h\n\nstd::string getDescription() const {\n    const char* AStatus_getDescription(const AStatus*) __INTRODUCED_IN_WEAK(30);\n\n    if (__builtin_available(android 30, *)) {\n        const char* cStr \u003d AStatus_getDescription(get());\n        std::string ret \u003d cStr;\n        AStatus_deleteDescription(cStr);\n        return ret;\n    }\n    return \"(not available)\";\n}\n\n// outside of the function above, AStatus_getDescription is still with \u0027strict\u0027 for non-APEX cases.\n\nThe rationale for this hack(?) is that as long as a client is using __builtin_available for an API, the use of the very API at the very call site shouldn\u0027t be bothered with the \u0027strict\u0027 flag which is for the unprepared rest. This is considered error-prone, and that\u0027s right. But given that this header is the only case that I have found so far, I don\u0027t think we will have many. And I don\u0027t think anyone is brave enough to do this without fully understanding what they are doing. So, I honestly don\u0027t feel that risky.\n\nI am not sure if we need the macro __INTRODUCED_IN_WEAK, but if it\u0027s needed, it should be with a big disclaimer of course.\n\nWhat do you think?",
      "parentUuid": "cfc19462_386aa4ca",
      "revId": "6d2dbdcf677760ab235349afb5a62f1b5920aa15",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49dec418_a54e03b8",
        "filename": "libc/include/android/versioning.h",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-09-16T12:09:42Z",
      "side": 1,
      "message": "\u003e This is considered error-prone\n\nThankfully, if someone makes a mistake on the version number, then the compiler gives an error:\n\nerror: availability does not match previous declaration [-Werror,-Wavailability]\n\nSo, one less worry there.",
      "parentUuid": "4d8985eb_350e95a6",
      "revId": "6d2dbdcf677760ab235349afb5a62f1b5920aa15",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d46190c4_f4d05fd9",
        "filename": "libc/include/android/versioning.h",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-09-16T19:26:28Z",
      "side": 1,
      "message": "\u003e I thought we could omit \u0027strict\u0027 as long as we process NDK headers with the versioner. The ifdef guards added by the tool has the same effect as \u0027strict\u0027.\n\nWe don\u0027t use versioner outside of bionic, so that would only add guards for bionic. iirc we\u0027d need to make some changes to versioner (at the very least we\u0027d need to rewrite all the ndk_headers rules) to accommodate running it on every NDK header.\n\nPlus, doing so would make it affect the platform anyway, since the platform NDK builds use the output of versioner. Would have the same affect as applying strict to all NDK APIs in the platform.\n\n\u003e Your idea actually inspired me to think this simple (albeit a little bit dirty) alternative...\n\nIt\u0027s a little odd, but I like it. Probably our best path forward atm. The fact that the compiler will warn you if you mismatch the versions makes me even less worried about it (thanks for checking!)",
      "parentUuid": "49dec418_a54e03b8",
      "revId": "6d2dbdcf677760ab235349afb5a62f1b5920aa15",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}