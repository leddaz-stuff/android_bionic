{
  "comments": [
    {
      "key": {
        "uuid": "1c0373ee_cdc48843",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-09-16T19:22:26Z",
      "side": 1,
      "message": "do we actually need to support this? who needs this, and when? can we insist that it\u0027s done while single-threaded instead?",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d73aa1b0_eb412a28",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1005967
      },
      "writtenOn": "2020-09-16T19:31:36Z",
      "side": 1,
      "message": "I\u0027m not entirely sure about disabling tagging process-wide, but we\u0027d need the exact same mechanism for an app to switch itself from async to sync.",
      "parentUuid": "1c0373ee_cdc48843",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e827d5e_44bb23e5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T19:36:04Z",
      "side": 1,
      "message": "The idea is that an app may call this after establishing that it needs to change the MTE setting (for example, the app may have its own \"experiments\" mechanism for controlling memory tagging in the field). Typically at the point at which an app\u0027s native code runs there are already multiple threads running, so we need to change this setting in all of them.",
      "parentUuid": "1c0373ee_cdc48843",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90a0c3a6_f7e6382a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-09-16T19:40:17Z",
      "side": 1,
      "message": "\u003e an app to switch itself from async to sync\n\nbecause you\u0027re thinking that wouldn\u0027t be a one-off decision in the manifest, that would be something they\u0027d do based on their number of crashes?\n\nmaybe _that_ should be what goes in the manifest: \"switch me to sync never/always/if-crashy\"?\n\ni\u0027m not sure how to manage pcc\u0027s \"i\u0027m running an experiment\" though.",
      "parentUuid": "8e827d5e_44bb23e5",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5bf5d9f6_4f393e73",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T19:47:43Z",
      "side": 1,
      "message": "\u003e maybe _that_ should be what goes in the manifest: \"switch me to sync never/always/if-crashy\"?\n\u003e \n\u003e i\u0027m not sure how to manage pcc\u0027s \"i\u0027m running an experiment\" though.\n\nRight, we thought about having this only be a manifest flag but concluded that it wouldn\u0027t provide enough flexibility. For example, \"if-crashy\" as decided by whom? If the app handles the crashes itself then whichever component decides that wouldn\u0027t necessarily see the crashes.",
      "parentUuid": "90a0c3a6_f7e6382a",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d84730b_b102a847",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-09-16T19:50:29Z",
      "side": 1,
      "message": "\u003e If the app handles the crashes itself then whichever component decides that wouldn\u0027t necessarily see the crashes\n\nif the app handles crashes itself, i think that\u0027s a bug they should fix. they\u0027re going to have so many other issues with getting all the other bits of data anyway, that\u0027s a clear \"don\u0027t do that then\".\n\n(though obviously jmgao\u0027s API doesn\u0027t exist _yet_, so we might need to fall back to some kind of \"assembly required\" solution if that doesn\u0027t make it for S.)",
      "parentUuid": "5bf5d9f6_4f393e73",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4065cc9_b6b58464",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1005967
      },
      "writtenOn": "2020-09-16T19:51:55Z",
      "side": 1,
      "message": "Exactly. I imagine logic like this can go into Crashlytics and any other crash reporting libraries. There is no way we can make the manifest expressive enough.\n\nTaken to the extreme, an app developer may notice a problem correlates with users doing a particular action in the app, and only enable sync when that is about to happen, perhaps with some sampling on top.",
      "parentUuid": "5bf5d9f6_4f393e73",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f935ccd_e7ff83ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T04:57:44Z",
      "side": 1,
      "message": "A few self-review comments while reading my code again.",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ba6af5f_156197e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T18:23:17Z",
      "side": 1,
      "message": "\u003e Patch Set 1:\n\u003e \n\u003e Why is this a new API rather than a new android_mallopt option?\n\nThe main reason is that I think {,android_}mallopt should only affect the heap, whereas this API also sets TCF0 which will impact MTE checking for the stack and globals.\n\nIf this is going to be added to one of the mallopt functions, then it should be added to mallopt and not android_mallopt, because it is intended to be a public API. (That would require a carveout of one of the M_ constants for Bionic because they are currently all owned by Scudo, but we can probably deal with that.)",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ab6719c_540b280a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-09-16T19:21:16Z",
      "side": 1,
      "message": "i think we need to make android_mallopt() public for S anyway, for our \"give apps more tuning knobs\" feature.\n\nwe can always give android_mallopt() a more general name (either \"slightly more general\" to make it clear that it\u0027s all memory, not just the heap, or \"fully general\" and have any kind of knob be collected there), but i\u0027d definitely prefer to avoid having a bunch of single-use API for tuning knobs.",
      "parentUuid": "6ba6af5f_156197e3",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dbf8e1a_fab67123",
        "filename": "libc/bionic/android_mem_init.cpp",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-09-16T19:21:16Z",
      "side": 1,
      "message": "we have a thread list (and no realistic hope of getting rid of it any time soon), which might be better?",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "667b2b8d_69acd3bc",
        "filename": "libc/bionic/android_mem_init.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T04:57:44Z",
      "side": 1,
      "message": "I\u0027ll need to read g_retval before this unlock to avoid a race with another thread calling this function.",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "985ca01f_32665e59",
        "filename": "libc/bionic/android_mem_init.cpp",
        "patchSetId": 1
      },
      "lineNbr": 140,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T04:57:44Z",
      "side": 1,
      "message": "I think this should be done unconditionally so that we don\u0027t zero init cached secondary allocations when MTE is enabled.",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9de161a_5a3ae79f",
        "filename": "libc/bionic/android_mem_init.cpp",
        "patchSetId": 1
      },
      "lineNbr": 144,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T04:57:44Z",
      "side": 1,
      "message": "This might cause build failures for now and will need to be protected with ANDROID_EXPERIMENTAL_MTE.",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a50df221_d797c827",
        "filename": "libc/include/android/mem_init.h",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2020-09-16T17:16:18Z",
      "side": 1,
      "message": "Sorry that it\u0027s taken me a few days to get back to you on this - but I\u0027m not convinced this should affect MTE, for a couple of reasons:\n 1. AFAICT, the fact that this disables MTE is the reason that stops us from being able to turn heap initialization back on afterwards. Given that the thread-only disable_mem_init() function only sets a thread-local variable, I assumed it would be a good use case where a developer would have a hot malloc that they don\u0027t want to eat the cost of MemInit on, and they could just flip it off/on again cheaply.\n 2. At least to me \"disabling heap memory initialization\" seems unrelated to MTE, and I\u0027d be surprised as a user for this side effect to happen. But, this could be solved with a slight rename to \"android_disable_heap_mitigations()\" or something.",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "958ea1a2_bad86c37",
        "filename": "libc/include/android/mem_init.h",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T18:23:17Z",
      "side": 1,
      "message": "1. Yes, the per-thread API permits toggling. There\u0027s no need to permit it for the per-process API since the API is expected to only be called once (e.g. after the app determines that some criteria for disabling it are satisfied) and not typically around a region of code since that would impact the other threads. Per-thread and per-process satisfy different use cases (wanting to disable only a few mallocs vs all mallocs) so we will need both.\n\n2. Renaming it seems fine. Maybe it shouldn\u0027t mention heap because the process-wide setting of TCF0 to NONE will impact not only heap but stack and globals.",
      "parentUuid": "a50df221_d797c827",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57755733_f809550e",
        "filename": "libc/include/android/mem_init.h",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2020-09-16T18:28:07Z",
      "side": 1,
      "message": "Ah - if we\u0027re supporting on/off for the per-thread that sounds good to me.\n\nWhat about \"android_disable_sanitization()\"?",
      "parentUuid": "958ea1a2_bad86c37",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdfe0644_6e37dffb",
        "filename": "libc/include/android/mem_init.h",
        "patchSetId": 1
      },
      "lineNbr": 35,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2020-09-16T19:10:24Z",
      "side": 1,
      "message": "Not sure about that name, since I don\u0027t think we\u0027re going to advertise any of these features as a \"sanitizer\". \"android_disable_memory_mitigations()\" could work maybe.",
      "parentUuid": "57755733_f809550e",
      "revId": "f8548c547d887f15f053f9113c011e1f7e1ffaee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}