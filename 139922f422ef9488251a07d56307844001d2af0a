{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6bd58b3d_cb16de77",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-10-26T15:39:32Z",
      "side": 1,
      "message": "did you forget to `git add` the header file too? or does the header file already say `__INTRODUCED_IN(21)`?\n\n(i think you\u0027ll actually want `__INTRODUCED_IN_NO_GUARD_FOR_NDK(21)` if you\u0027re going to add this to libandroid_support...)",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7376525f_b39432a7",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-26T23:50:28Z",
      "side": 1,
      "message": "I add `__INTRODUCED_IN(21)` and libandroid_support is in the ndk repo",
      "parentUuid": "6bd58b3d_cb16de77",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4285dc87_98f77bb2",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2021-10-27T00:19:08Z",
      "side": 1,
      "message": "__INTRODUCED_IN_NO_GUARD_FOR_NDK is what gets used when we want the decl but there isn\u0027t a definition (in bionic or in libandroid_support). When we define it in libandroid_support we also add the decl to the libandroid_support headers.\n\nFor this case you do want to add the __INTRODUCED_IN(21) to the bionic header.",
      "parentUuid": "7376525f_b39432a7",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "68cc9f7b_f8ab9abd",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-27T16:53:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4285dc87_98f77bb2",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d719e017_86508486",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 586,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "Aside: The two sizeof(buf) expressions in this function should be NUM_WCHARS(sizeof(buf)).\n\n(I happened to notice this while looking for instances of EXPECT_STREQ / ASSERT_STREQ that used a wide string. I didn\u0027t see any more instances of this bug.)\n\nNUM_WCHARS in this file probably ought to be replaced with std::size.",
      "range": {
        "startLine": 586,
        "startChar": 33,
        "endLine": 586,
        "endChar": 44
      },
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ed6ae3d_ac981e4c",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 816,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "Do we need the T template parameter? For WcsToFloatFn, T can be any of float, double, or long double, but for MbsToWcsFn, the return type is always just size_t.\n\nMaybe we can just inline the content of MbsToWcsFn into TEST(wchar, mbstowcs)?",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f497eed_102659fe",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 816,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-26T23:50:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4ed6ae3d_ac981e4c",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c742f13_37619188",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "These are single-byte characters, so maybe we should drop the L prefix?\n\n  char bytes[] \u003d { \u0027h\u0027, \u0027e\u0027, \u0027l\u0027, \u0027l\u0027, \u0027o\u0027, \u0027\\0\u0027 };\n  const char bad_chars[] \u003d { \u0027h\u0027, \u0027i\u0027, static_cast\u003cchar\u003e(0xff), \u0027\\0\u0027 };\n\nIt could be simplified, but it looks like the existing wcstombs_wcrtombs test also breaks the string up char-by-char. e.g.: It could just be this:\n\n    const char chars[] \u003d \"hello\";\n    const char bad_chars[] \u003d \"hi\\xff\";\n\nMaybe we should make the out[] buffer larger (e.g. 256 elements) so it\u0027s as large as the largest mbstowcs call?",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76251c34_25d990be",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-26T23:50:28Z",
      "side": 1,
      "message": "In this case, conversion error will be returned when mbstowcs call: The next wide character to be stored would exceed len. So that\u0027s why I set it smaller than the largest capacity to get the expected error. Ohhh, should I add one case that cause stack smashing?",
      "parentUuid": "9c742f13_37619188",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3184a5ec_4884b3c2",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-28T23:32:44Z",
      "side": 1,
      "message": "\u003e Ohhh, should I add one case that cause stack smashing?\n\nI don\u0027t think we need to do that? That would tend to make the test fail, I think.\n\nI was wondering whether it\u0027s OK to set the mbstowcs length parameter larger than the actual size of the output buffer, if we know that mbstowcs will stop before it exceeds the buffer size. It looks like that is allowed by C11 and POSIX, but the Linux man pages has a line, \"The programmer must ensure that there is room for at least n wide characters at dest.\" Practically, I think it would work, unless some sanitizer/fortify-mode rejected it.\n\nI think it would make sense to modify the n\u003d1 test to verify that it writes exactly one wchar (and does not write a NUL wchar). e.g. Use [w]memset to fill out with non-zero characters first, then verify afterwards that the filler is still there, but the first wchar is changed.",
      "parentUuid": "76251c34_25d990be",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82acb4d9_f1104ead",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-29T18:34:12Z",
      "side": 1,
      "message": "So is it like line 162 in wcstombs test : \n  memset(bytes, \u0027x\u0027, sizeof(bytes));\n  EXPECT_EQ(0U, wcstombs(bytes, chars, 0));\n  memset(bytes, \u0027x\u0027, sizeof(bytes));\n  EXPECT_EQ(4U, wcstombs(bytes, chars, 4));\n  bytes[5] \u003d 0;\n  EXPECT_STREQ(\"hellx\", bytes);\n  memset(bytes, \u0027x\u0027, sizeof(bytes));",
      "parentUuid": "3184a5ec_4884b3c2",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44edf095_0e04c3e3",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "I think we could add some ASSERT_STREQ(L\"...\", out) lines here? For the n\u003d0 and n\u003d1 cases, we\u0027d need to [w]memset the out buffer beforehand.",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e08d865_cbefc090",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-29T18:41:00Z",
      "side": 1,
      "message": "I think I can use something like \"char bytes[BUFSIZ]\" to replace \"out\" array and test whether they are equal, kind of like the comments above. Also it will include all cases.",
      "parentUuid": "44edf095_0e04c3e3",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}