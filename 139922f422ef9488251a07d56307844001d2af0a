{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6bd58b3d_cb16de77",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-10-26T15:39:32Z",
      "side": 1,
      "message": "did you forget to `git add` the header file too? or does the header file already say `__INTRODUCED_IN(21)`?\n\n(i think you\u0027ll actually want `__INTRODUCED_IN_NO_GUARD_FOR_NDK(21)` if you\u0027re going to add this to libandroid_support...)",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7376525f_b39432a7",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-26T23:50:28Z",
      "side": 1,
      "message": "I add `__INTRODUCED_IN(21)` and libandroid_support is in the ndk repo",
      "parentUuid": "6bd58b3d_cb16de77",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4285dc87_98f77bb2",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2021-10-27T00:19:08Z",
      "side": 1,
      "message": "__INTRODUCED_IN_NO_GUARD_FOR_NDK is what gets used when we want the decl but there isn\u0027t a definition (in bionic or in libandroid_support). When we define it in libandroid_support we also add the decl to the libandroid_support headers.\n\nFor this case you do want to add the __INTRODUCED_IN(21) to the bionic header.",
      "parentUuid": "7376525f_b39432a7",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "68cc9f7b_f8ab9abd",
        "filename": "libc/libc.map.txt",
        "patchSetId": 1
      },
      "lineNbr": 634,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-27T16:53:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4285dc87_98f77bb2",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d719e017_86508486",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 586,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "Aside: The two sizeof(buf) expressions in this function should be NUM_WCHARS(sizeof(buf)).\n\n(I happened to notice this while looking for instances of EXPECT_STREQ / ASSERT_STREQ that used a wide string. I didn\u0027t see any more instances of this bug.)\n\nNUM_WCHARS in this file probably ought to be replaced with std::size.",
      "range": {
        "startLine": 586,
        "startChar": 33,
        "endLine": 586,
        "endChar": 44
      },
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ed6ae3d_ac981e4c",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 816,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "Do we need the T template parameter? For WcsToFloatFn, T can be any of float, double, or long double, but for MbsToWcsFn, the return type is always just size_t.\n\nMaybe we can just inline the content of MbsToWcsFn into TEST(wchar, mbstowcs)?",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f497eed_102659fe",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 816,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-26T23:50:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4ed6ae3d_ac981e4c",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c742f13_37619188",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "These are single-byte characters, so maybe we should drop the L prefix?\n\n  char bytes[] \u003d { \u0027h\u0027, \u0027e\u0027, \u0027l\u0027, \u0027l\u0027, \u0027o\u0027, \u0027\\0\u0027 };\n  const char bad_chars[] \u003d { \u0027h\u0027, \u0027i\u0027, static_cast\u003cchar\u003e(0xff), \u0027\\0\u0027 };\n\nIt could be simplified, but it looks like the existing wcstombs_wcrtombs test also breaks the string up char-by-char. e.g.: It could just be this:\n\n    const char chars[] \u003d \"hello\";\n    const char bad_chars[] \u003d \"hi\\xff\";\n\nMaybe we should make the out[] buffer larger (e.g. 256 elements) so it\u0027s as large as the largest mbstowcs call?",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76251c34_25d990be",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-26T23:50:28Z",
      "side": 1,
      "message": "In this case, conversion error will be returned when mbstowcs call: The next wide character to be stored would exceed len. So that\u0027s why I set it smaller than the largest capacity to get the expected error. Ohhh, should I add one case that cause stack smashing?",
      "parentUuid": "9c742f13_37619188",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3184a5ec_4884b3c2",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-28T23:32:44Z",
      "side": 1,
      "message": "\u003e Ohhh, should I add one case that cause stack smashing?\n\nI don\u0027t think we need to do that? That would tend to make the test fail, I think.\n\nI was wondering whether it\u0027s OK to set the mbstowcs length parameter larger than the actual size of the output buffer, if we know that mbstowcs will stop before it exceeds the buffer size. It looks like that is allowed by C11 and POSIX, but the Linux man pages has a line, \"The programmer must ensure that there is room for at least n wide characters at dest.\" Practically, I think it would work, unless some sanitizer/fortify-mode rejected it.\n\nI think it would make sense to modify the n\u003d1 test to verify that it writes exactly one wchar (and does not write a NUL wchar). e.g. Use [w]memset to fill out with non-zero characters first, then verify afterwards that the filler is still there, but the first wchar is changed.",
      "parentUuid": "76251c34_25d990be",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82acb4d9_f1104ead",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-29T18:34:12Z",
      "side": 1,
      "message": "So is it like line 162 in wcstombs test : \n  memset(bytes, \u0027x\u0027, sizeof(bytes));\n  EXPECT_EQ(0U, wcstombs(bytes, chars, 0));\n  memset(bytes, \u0027x\u0027, sizeof(bytes));\n  EXPECT_EQ(4U, wcstombs(bytes, chars, 4));\n  bytes[5] \u003d 0;\n  EXPECT_STREQ(\"hellx\", bytes);\n  memset(bytes, \u0027x\u0027, sizeof(bytes));",
      "parentUuid": "3184a5ec_4884b3c2",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3968ff9_bac01bb0",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-10-29T18:49:42Z",
      "side": 1,
      "message": "yeah, though oddly i don\u0027t appear to have checked that (say) the first call that returned 0 didn\u0027t actually preserve all the bytes. the second test (returning 4) makes more sense :-)",
      "parentUuid": "82acb4d9_f1104ead",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "629683b9_26991670",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 895,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-11-02T18:12:25Z",
      "side": 1,
      "message": "Get it :D I will add some tests to verify whether it is filled :D",
      "parentUuid": "a3968ff9_bac01bb0",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44edf095_0e04c3e3",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-10-26T01:56:47Z",
      "side": 1,
      "message": "I think we could add some ASSERT_STREQ(L\"...\", out) lines here? For the n\u003d0 and n\u003d1 cases, we\u0027d need to [w]memset the out buffer beforehand.",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e08d865_cbefc090",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-29T18:41:00Z",
      "side": 1,
      "message": "I think I can use something like \"char bytes[BUFSIZ]\" to replace \"out\" array and test whether they are equal, kind of like the comments above. Also it will include all cases.",
      "parentUuid": "44edf095_0e04c3e3",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e112718_dcc51b18",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-10-29T18:49:42Z",
      "side": 1,
      "message": "or there\u0027s a wmemcmp() function you can use to do a wchar_t array comparison.\n\ni think a bigger missing part of this test is to check that mbstowcs() converts some actually _multibyte_ UTF-8 to the corresponding codepoints. see the wctomb_wcrtomb test in this file for examples of the interesting cases (L70-L94).",
      "parentUuid": "3e08d865_cbefc090",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb416694_4ce937bc",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-10-29T22:40:52Z",
      "side": 1,
      "message": "So I should add mbrstowcs() like wcstombs_wcrstombs test? and I find a specific test for mbtowc() and I guess I need to rewrite and rename it to mbtowc_mbrtowc test",
      "parentUuid": "9e112718_dcc51b18",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49cbeb50_14df5cb8",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-10-29T23:00:20Z",
      "side": 1,
      "message": "yeah, wctomb_wcrtomb tests the \"single character\" API, so wcstombs_wcrstombs might want to look pretty similar, but with multiple characters.\n\ntbh, i think it\u0027s fine to mostly just test with ASCII, but we should definitely check that we _can_ handle actual multibyte sequences properly.\n\npersonally i tend to be mostly fine with \"f() is implemented by multiple calls to g(), so i don\u0027t actually need to re-test every single g() test case --- i just need to check that f() calls g() correctly\".\n\nif you want to get really fancy (or just want the computer to tell you whether or not you\u0027ve done a good job), the instructions from README.md for doing a coverage run are probably helpful:\n```\n## Gathering test coverage\n\nTo get test coverage for bionic, use `//bionic/build/coverage.sh`. Before\nrunning, follow the instructions at the top of the file to rebuild bionic with\ncoverage instrumentation.\n```\nthough obviously coverage _can\u0027t_ spot things like \"did we actually try the multi-byte case, or did we only do ASCII?\", it is really great for confirming that you\u0027ve actually covered all the interesting _lines_ of code.\n\n(one day -- hopefully not too many years from now -- we\u0027ll have this shown directly in gerrit. until then, you need to run a report manually :-( .)",
      "parentUuid": "eb416694_4ce937bc",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7663e2e_5987eabb",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-11-01T18:43:00Z",
      "side": 1,
      "message": "Okay, gotcha. But I have a question. I find test_mbsrtowcs() already exists but there is no multiply-bytes utf-8 cases when calling mbsrtowcs(). I guess I should add cases in this functions?",
      "parentUuid": "49cbeb50_14df5cb8",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c4124d9_69b0b15e",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-11-01T18:59:44Z",
      "side": 1,
      "message": "i think there is; they\u0027re just combined all into one string:\n```\n  constexpr const char* VALID \u003d \"A\" \"\\xc2\\xa2\" \"\\xe2\\x82\\xac\" \"\\xf0\\xa4\\xad\\xa2\" \"ef\";\n```\nthat\u0027s one single-byte character (A), one two-byte character (¢), one three-byte character (€), one four-byte character (a 漢字 that isn\u0027t in my font, so i\u0027m assuming it\u0027s not in yours either: https://www.fileformat.info/info/unicode/char/24b62/index.htm), and then two more single-byte characters (e and f).\n\nunless/until proven otherwise, that seems fine to me. (it\u0027s actually the _invalid_ possibilities that seem less well tested; there\u0027s no over-long encoding, say. but don\u0027t worry about it: your job is never to make all the tests perfect. \"good enough is good enough\" --- it\u0027s usually better for everyone to do enough for people to have confidence in the code and move on to fixing the next bug, rather than spend the next six months coming up with the perfect unicode test suite :-) )\n\nin fact, given that the implementation of the function you\u0027re adding the test for is trivial (https://source.corp.google.com/android/bionic/libc/upstream-openbsd/lib/libc/locale/wcstombs.c;l\u003d36?q\u003dfile:bionic%20wcstombs\u0026sq\u003dpackage:%5Eandroid$) i personally think it\u0027s fine to just have a \"smoke test\" here that relies on the fact that all the real work is actually done by wcsrtombs(). i\u0027m struggling to see any value in duplicating tests here, and some _negative_ value since duplicated tests need to be maintained just like duplicated code...\n\n(the same is true for mbstowcs() too, now i\u0027ve looked at the implementation: https://source.corp.google.com/android/bionic/libc/upstream-openbsd/lib/libc/locale/mbstowcs.c;l\u003d37?q\u003dfile:bionic%20mbstowcs\u0026sq\u003dpackage:%5Eandroid$)",
      "parentUuid": "e7663e2e_5987eabb",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cbacf853_4e669b11",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-11-02T18:39:55Z",
      "side": 1,
      "message": "A 漢字 that is in my font :D and it is the correct traditional version.\n\nOkay I just add \"smoke test\" for wcsrtombs() and mbstowcs() :D \n\nOne is to verify whether these functions are called correctly and whether characters are filled.\n\nThe other is to add multiply-bytes utf-8 cases in test_mbsrtowcs() :-)",
      "parentUuid": "2c4124d9_69b0b15e",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ec5aef4_079a50b1",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-11-03T01:31:53Z",
      "side": 1,
      "message": "\u003e A 漢字 that is in my font :D and it is the correct traditional version.\n\nheh, after i hit \"send\" it did occur to me that it was quite possible that you have better fonts installed. when you know less than 50 characters, two of which are 漢 and 字, you don\u0027t need much font coverage :-)",
      "parentUuid": "cbacf853_4e669b11",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9db560e0_ebe68b5a",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-11-03T04:41:34Z",
      "side": 1,
      "message": "I\u0027m able to see both 漢 and 字 on my gLinux desktop. I do have a Japanese IME installed. Chrome seems to prefer rendering U+6F22(漢) as Japanese on my machine, while Firefox prefers the traditional glyph. Both browsers can render both glyphs for text marked with a language code (ja or zh).",
      "parentUuid": "1ec5aef4_079a50b1",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9c3adff_8f55a46b",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-11-03T23:38:06Z",
      "side": 1,
      "message": "oh, yeah, 漢字 are the chinese characters for \"chinese characters\"; 字 is the \"ji\" in emoji --- they\u0027re definitely in the first 50 or so characters anyone learns :-)\n\nthe \"difficult\" character was U+24B62 (\u0027𤭢\u0027) which according to https://en.wiktionary.org/wiki/%F0%A4%AD%A2 doesn\u0027t even one that has a korean name (which suggests i probably have never seen this character in real life).",
      "parentUuid": "9db560e0_ebe68b5a",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "165d0b2d_4756b308",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1229339
      },
      "writtenOn": "2021-11-04T00:09:20Z",
      "side": 1,
      "message": "Oh, sorry, I misread. Yeah, it looks like my computer\u0027s fonts also don\u0027t render U+24B62 (\u0027𤭢\u0027).",
      "parentUuid": "a9c3adff_8f55a46b",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4f5f263_85f47991",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-11-04T00:18:23Z",
      "side": 1,
      "message": "So based on the discussion, are there any more action items for me in this comment? Do I need to cover the \"difficult\" character U+24B62?",
      "parentUuid": "165d0b2d_4756b308",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5369259_434e500c",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-11-04T01:02:40Z",
      "side": 1,
      "message": "no, i think the test case that\u0027s already in test_mbsrtowcs is sufficient. like i said, i\u0027m happy to assume things about the implementation (such as \"mbstowcs is implemented in terms of mbsrtowcs\") and prefer that to duplicating tests. i honestly don\u0027t see much value in a mbstowcs test _at all_ given that, which is perhaps why i didn\u0027t write one when i wrote the more interesting test_mbsrtowcs :-)\n\nfor me, just converting \"hello\" seems like plenty (perhaps with a comment saying \"this is just a trivial wrapper around mbsrtowcs; see there for full tests\").\n\nif you/anyone else does think of missing tests, we should add them to test_mbsrtowcs instead.",
      "parentUuid": "b4f5f263_85f47991",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65832b97_7b46171d",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-11-04T16:12:32Z",
      "side": 1,
      "message": "Okay I added utf8 encoding tests in test_mbsrtowcs() although it is very similar to the previous tests...",
      "parentUuid": "b5369259_434e500c",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "215b33bd_ab849c00",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-11-04T23:37:12Z",
      "side": 1,
      "message": "(sorry, meant to follow up on this sooner...)\n\nfwiw, i took a look and the computers say we already have 100% coverage: https://source.corp.google.com/android/bionic/libc/upstream-openbsd/lib/libc/locale/mbstowcs.c;l\u003d2?q\u003dfile:mbstowcs\u0026sq\u003dpackage:%5Eandroid$\n\nand also for wcstombs: https://source.corp.google.com/android/bionic/libc/upstream-openbsd/lib/libc/locale/wcstombs.c\n\nso i don\u0027t think we need any test changes for this CL at all.\n\n(you can see the coverage by going into the \"layers\" drop-down in the top right of the screen, then choosing \"file coverage\". green means \"this line is covered\"; lines without coverage show up red.)",
      "parentUuid": "65832b97_7b46171d",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bea836bc_1a443883",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1890456
      },
      "writtenOn": "2021-11-05T21:14:41Z",
      "side": 1,
      "message": "ohhh I see the coverage for these two functions. So there should be no changes in the wchar_test.cpp file, right? Okay, I will delete them.",
      "parentUuid": "215b33bd_ab849c00",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33608def_430b3140",
        "filename": "tests/wchar_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 914,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-11-05T21:15:25Z",
      "side": 1,
      "message": "sgtm.",
      "parentUuid": "bea836bc_1a443883",
      "revId": "139922f422ef9488251a07d56307844001d2af0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}