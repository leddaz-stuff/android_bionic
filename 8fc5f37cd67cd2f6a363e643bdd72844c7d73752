{
  "comments": [
    {
      "key": {
        "uuid": "f183336d_e8bbf895",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 234,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "seems unnecessary.",
      "range": {
        "startLine": 233,
        "startChar": 0,
        "endLine": 234,
        "endChar": 16
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9df08bda_db5484a6",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "You should probably do a __builtin_add_overflow just in case. Otherwise, this could overflow and pass when it really would have failed. It\u0027s probably very unlikely to overflow without triggering some other overflow condition though.",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c5a3e3e_bb28245f",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "if this is speculative, you could use memory_order_relaxed here.  if you like more accuracy, you could use memory_order_acquire.\n\nsize_t temp;\nreturn !builtin_add_overflow(atomic_load_explicit(\u0026gAllocated, memory_order_acquire), bytes, \u0026temp) \u0026\u0026 temp \u003c\u003d gAllocLimit;",
      "parentUuid": "9df08bda_db5484a6",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56589881_b2a43825",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "You probably want to check for an overflow condition.",
      "range": {
        "startLine": 239,
        "startChar": 11,
        "endLine": 239,
        "endChar": 73
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5eee4212_51bb04c1",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "shouldn\u0027t overflow as is size_t",
      "parentUuid": "56589881_b2a43825",
      "range": {
        "startLine": 239,
        "startChar": 11,
        "endLine": 239,
        "endChar": 73
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97e2846b_113f1c55",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 244,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "could overflow, but really calloc should fail.",
      "range": {
        "startLine": 244,
        "startChar": 19,
        "endLine": 244,
        "endChar": 41
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52b2dc73_469e7736",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 250,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "this could go below 0 (and underflow) due to untracked memory (can this happen due to estimate on line 306)?  Perhaps we should clamp to 0 (and track the underflow amount) - the technically correct method is the following, but not sure if an approximate method is better or adding an substantial 32GB symmetric offset to gAllocated and gAllocLimit (assuming we\u0027re 64b size_t).\n\nconst size_t size \u003d Malloc(malloc_usable_size)(mem);\ndo {\n  const size_t allocated \u003d atomic_load_explicit(\u0026gAllocated, memory_order_acquire);\n  const size_t newAllocated \u003d allocated \u003e size ? allocated - size : 0;\n} while (!atomic_compare_exchange_weak(\u0026gAllocated, allocated, newAllocated, memory_order_acq_rel));\n\nlimit_realloc and limit_posix_memalign need some modification to use this.",
      "range": {
        "startLine": 250,
        "startChar": 0,
        "endLine": 250,
        "endChar": 65
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d56c3115_cab20a96",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "Since you might get more bytes allocated than you requested, you can pass the check_limit but actually wind up larger than the limit because the usable size is larger. The total bytes allocated should still be completely accurate though. Also, multiple threads allocating at the same time could push you past the limit.\n\nI would assume this is best effort, so maybe that\u0027s okay.",
      "range": {
        "startLine": 255,
        "startChar": 19,
        "endLine": 255,
        "endChar": 24
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4227e8d1_5e28b079",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-09T00:52:58Z",
      "side": 1,
      "message": "Yes, exactly.",
      "parentUuid": "d56c3115_cab20a96",
      "range": {
        "startLine": 255,
        "startChar": 19,
        "endLine": 255,
        "endChar": 24
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b242c2db_a2c29b8f",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 282,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "This check isn\u0027t correct. You need to do some manual checking here.\n\nSpecifically, if old_mem !\u003d nullptr and bytes \u003c\u003d malloc_usable_size(old_mem), then you could either make the realloc call, or do nothing and return the original pointer.",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 282,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32739768_801996f5",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-13T16:53:04Z",
      "side": 1,
      "message": "After thinking about this for a bit, I think you should use the mallopt functionality rather than add a new function.",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b8c1228_e7d2747b",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-13T17:39:10Z",
      "side": 1,
      "message": "I considered that, but decided against it because the second argument to mallopt is an int and it\u0027s entirely possible that we\u0027ll want to set the limit to \u003e2GB on 64-bit machines. We could work around that by having the argument mean the number of pages or something like that, but it seems like that would be less clear than a separate function.\n\nAnother reason is that mallopt is exposed to the NDK, and there\u0027s no real benefit to exposing this function to the NDK; it could even cause compatibility problems if apps start using this function and the platform starts allocating more memory.",
      "parentUuid": "32739768_801996f5",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2043ba4d_e15e7073",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-11-14T03:31:41Z",
      "side": 1,
      "message": "Another option would be adding a new general-purpose mallopt2 with an improved signature. I\u0027m not worried about giving NDK applications being able to shoot themselves in the foot: they can already call things like sigaction(2).\n\nPersonally, though, I think a new function is fine. cferris, what makes you prefer mallopt?",
      "parentUuid": "3b8c1228_e7d2747b",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf8262ce_25ed3273",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "if you\u0027re adding new functionality, what about\n\nandroid_get_current_allocation()?",
      "parentUuid": "2043ba4d_e15e7073",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a6c9881_ae3b9389",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "These mallctl calls are deeply tied to the implementation of the allocator. You can\u0027t use this because there are already two allocators in use for Q.\n\nInstead you should replace this with something like:\n\natomic_init(\u0026gAllocated, mallinfo().uordblks);\n\nAnd you\u0027ll have to deal with the fact that it\u0027s going to be close but not completely accurate unless the system isn\u0027t doing anything.",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1beda7e1_670f44fd",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-09T00:52:58Z",
      "side": 1,
      "message": "As best as I can tell, Scudo works by adding a library to an executable\u0027s DT_NEEDED that interposes the regular libc allocator. That means that none of bionic\u0027s malloc_dispatch mechanism actually comes into play when Scudo is in use.\n\nSo, what is the effect of calling android_set_allocation_limit() in a Scudo-enabled process? It seems like there would be no effect at all because this function only modifies globals that are ultimately unused in such a process. So if Scudo wants this function to work properly, it seems like it should also interpose that function.\n\nThat said, there has been a change to limitProcessMemory to make it check for Scudo and call its version of android_set_allocation_limit if it is present: https://android-review.googlesource.com/c/platform/frameworks/av/+/793077\n\nSo it seems like there will be nothing to do once Scudo is integrated into the media processes, but it might be a good idea to add an interceptor to Scudo in order to make sure that calling android_set_allocation_limit() has an effect and to simplify the implementation of limitProcessMemory a little.",
      "parentUuid": "3a6c9881_ae3b9389",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46935206_05c279f9",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "i\u0027ll need to check on Scudo :-).",
      "parentUuid": "1beda7e1_670f44fd",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a4e0c0c_0659f972",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 334,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "should this be all or none  (not sure if that would be more race-free)  Doesn\u0027t seem that WriteProtected is thread-safe...\n\ne.g. if (globals-\u003emalloc_dispatch.calloc \u003d\u003d nullptr \u0026\u0026 ... \u003d\u003d nullptr \u0026\u0026...) {\n}",
      "range": {
        "startLine": 319,
        "startChar": 0,
        "endLine": 334,
        "endChar": 5
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}