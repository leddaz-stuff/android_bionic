{
  "comments": [
    {
      "key": {
        "uuid": "9df08bda_db5484a6",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "You should probably do a __builtin_add_overflow just in case. Otherwise, this could overflow and pass when it really would have failed. It\u0027s probably very unlikely to overflow without triggering some other overflow condition though.",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56589881_b2a43825",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "You probably want to check for an overflow condition.",
      "range": {
        "startLine": 239,
        "startChar": 11,
        "endLine": 239,
        "endChar": 73
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d56c3115_cab20a96",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "Since you might get more bytes allocated than you requested, you can pass the check_limit but actually wind up larger than the limit because the usable size is larger. The total bytes allocated should still be completely accurate though. Also, multiple threads allocating at the same time could push you past the limit.\n\nI would assume this is best effort, so maybe that\u0027s okay.",
      "range": {
        "startLine": 255,
        "startChar": 19,
        "endLine": 255,
        "endChar": 24
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4227e8d1_5e28b079",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-09T00:52:58Z",
      "side": 1,
      "message": "Yes, exactly.",
      "parentUuid": "d56c3115_cab20a96",
      "range": {
        "startLine": 255,
        "startChar": 19,
        "endLine": 255,
        "endChar": 24
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b242c2db_a2c29b8f",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 282,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "This check isn\u0027t correct. You need to do some manual checking here.\n\nSpecifically, if old_mem !\u003d nullptr and bytes \u003c\u003d malloc_usable_size(old_mem), then you could either make the realloc call, or do nothing and return the original pointer.",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 282,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32739768_801996f5",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-13T16:53:04Z",
      "side": 1,
      "message": "After thinking about this for a bit, I think you should use the mallopt functionality rather than add a new function.",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b8c1228_e7d2747b",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-13T17:39:10Z",
      "side": 1,
      "message": "I considered that, but decided against it because the second argument to mallopt is an int and it\u0027s entirely possible that we\u0027ll want to set the limit to \u003e2GB on 64-bit machines. We could work around that by having the argument mean the number of pages or something like that, but it seems like that would be less clear than a separate function.\n\nAnother reason is that mallopt is exposed to the NDK, and there\u0027s no real benefit to exposing this function to the NDK; it could even cause compatibility problems if apps start using this function and the platform starts allocating more memory.",
      "parentUuid": "32739768_801996f5",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a6c9881_ae3b9389",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "These mallctl calls are deeply tied to the implementation of the allocator. You can\u0027t use this because there are already two allocators in use for Q.\n\nInstead you should replace this with something like:\n\natomic_init(\u0026gAllocated, mallinfo().uordblks);\n\nAnd you\u0027ll have to deal with the fact that it\u0027s going to be close but not completely accurate unless the system isn\u0027t doing anything.",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1beda7e1_670f44fd",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-09T00:52:58Z",
      "side": 1,
      "message": "As best as I can tell, Scudo works by adding a library to an executable\u0027s DT_NEEDED that interposes the regular libc allocator. That means that none of bionic\u0027s malloc_dispatch mechanism actually comes into play when Scudo is in use.\n\nSo, what is the effect of calling android_set_allocation_limit() in a Scudo-enabled process? It seems like there would be no effect at all because this function only modifies globals that are ultimately unused in such a process. So if Scudo wants this function to work properly, it seems like it should also interpose that function.\n\nThat said, there has been a change to limitProcessMemory to make it check for Scudo and call its version of android_set_allocation_limit if it is present: https://android-review.googlesource.com/c/platform/frameworks/av/+/793077\n\nSo it seems like there will be nothing to do once Scudo is integrated into the media processes, but it might be a good idea to add an interceptor to Scudo in order to make sure that calling android_set_allocation_limit() has an effect and to simplify the implementation of limitProcessMemory a little.",
      "parentUuid": "3a6c9881_ae3b9389",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}