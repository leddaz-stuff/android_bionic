{
  "comments": [
    {
      "key": {
        "uuid": "4036c056_01b5a975",
        "filename": "benchmarks/time_benchmark.cpp",
        "patchSetId": 4
      },
      "lineNbr": 68,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-11-10T18:33:24Z",
      "side": 1,
      "message": "is there a reason you chose this rather than the typical \"invalid int\" -1?",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 23
      },
      "revId": "b1123df0eaa69cae00a913619cbd0c422faff4b2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "40dac54b_cb7e4272",
        "filename": "benchmarks/time_benchmark.cpp",
        "patchSetId": 4
      },
      "lineNbr": 68,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2017-11-10T18:50:26Z",
      "side": 1,
      "message": "Anything other than the current reserved set will do of course. Just picked a number that is _positive_.\n\nI chose 0x7F7F for implementations that does bad stuff, masks the value (except for CLOCK_MASK, but one of %MAX_CLOCKS, byte or word) it still lands as unsupported positive. Only last week was one of the assembler implementations (aarch64 vdso) fixed with regards to masking an address to 32 bits (breaking vdso for calls where the return data aligns on a 4GB boundary), so plausible mistake. This value in my mind was the best chance of not hitting one of those mistakes and truly being unsupported giving me a useful benchmark number.",
      "parentUuid": "4036c056_01b5a975",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 23
      },
      "revId": "b1123df0eaa69cae00a913619cbd0c422faff4b2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "83928567_c837e689",
        "filename": "benchmarks/time_benchmark.cpp",
        "patchSetId": 4
      },
      "lineNbr": 68,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-11-10T19:03:53Z",
      "side": 1,
      "message": "please don\u0027t do that. write a unit test for that kind of thing. benchmarks are not the place to try to write tests.",
      "parentUuid": "40dac54b_cb7e4272",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 23
      },
      "revId": "b1123df0eaa69cae00a913619cbd0c422faff4b2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22683376_eeeded9e",
        "filename": "benchmarks/time_benchmark.cpp",
        "patchSetId": 4
      },
      "lineNbr": 68,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2017-11-10T19:43:23Z",
      "side": 1,
      "message": "What about (INT8_MAX + (INT8_MAX \u003c\u003c 8)) instead to signal the clear intentions (out of range, stay positive)?\n\nI do not care. It is a minor nit. In my tests I did try -1 and works on arm and arm64 with no surprises. I did not expect a surprise as I know the code it is hitting. But I am thinking in a broader sense about _all_ CPUs and their private implementations.\n\nThis number was chosen to _reduce_ the chances of code differences and implementations affecting the desired comparable results. Selected on a hunch (and only a hunch mind you) to make the test stand the test of time, bugs and architectural changes.\n\n-1 will could, for example, trigger a branch less than path on a switch or if statement which will not compare 1:1 against any of the other positive numbers. INT16_MAX could still hit it on a byte mask, INT32_MAX on word mask.",
      "parentUuid": "83928567_c837e689",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 23
      },
      "revId": "b1123df0eaa69cae00a913619cbd0c422faff4b2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}