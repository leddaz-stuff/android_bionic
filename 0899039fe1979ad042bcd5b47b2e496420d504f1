{
  "comments": [
    {
      "key": {
        "uuid": "3c400875_403d30ef",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T00:04:45Z",
      "side": 1,
      "message": "Could we do a drive-by fix and rename this, e.g. to nthreads?\n\nThis is not a counter.  And there are counters nearby, so this is really confusing.",
      "range": {
        "startLine": 126,
        "startChar": 17,
        "endLine": 126,
        "endChar": 24
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bc5dd861_99c69b19",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2015-02-05T00:33:18Z",
      "side": 1,
      "message": "(\u0027thread_count\u0027 would be our usual style.)",
      "parentUuid": "3c400875_403d30ef",
      "range": {
        "startLine": 126,
        "startChar": 17,
        "endLine": 126,
        "endChar": 24
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c8dbc43_511ed68f",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-05T22:56:25Z",
      "side": 1,
      "message": "Done. By the way, as __futex_wake_ex uses int, I didn\u0027t change the type to unsigned int.",
      "parentUuid": "bc5dd861_99c69b19",
      "range": {
        "startLine": 126,
        "startChar": 17,
        "endLine": 126,
        "endChar": 24
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c3e00ec_9f04b33b",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T00:04:45Z",
      "side": 1,
      "message": "Isn\u0027t this whole thing equivalent to\n\natomic_fetch_and_sub(cond_value_ptr, COND_COUNTER_STEP, memory_order_release)  ?\n\nAm I missing something?\n\nWe should really be operating on unsigned ints here, since\nwe are counting on 2s complement behavior for overflows.\n\nUnless we are trying to provide stronger than Posix guarantees (which I think we shouldn\u0027t), memory_order_relaxed is fine here, no matter which atomic operation you choose.  The woken thread cannot rely on seeing memory accesses performed before the signal call anyway; it might have spuriously woken up just before the signal was executed.  I would add something like that as a comment.\n\nI don\u0027t even think there is much danger of exposing client bugs, since the futex_wake_ex probably already has the fence anyway, and we can\u0027t eliminate that.",
      "range": {
        "startLine": 128,
        "startChar": 1,
        "endLine": 145,
        "endChar": 95
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc26457_7dc54b0f",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-05T22:56:25Z",
      "side": 1,
      "message": "In current implementation, it equals to atomic_fetch_and_sub, as the flags are all in lowest bits.\nI think it is more robust/readable to use COND_COUNTER_MASK to make sure it will not affect flags?\nBy the way, I don\u0027t know if there is any reason we should use subtraction instead of addition,\naddition is more intuitive to me, so I changed it.\npthread_cond_t value type is changed to unsigned int. \n\nI am not sure I truely understand you idea. Below is my consideration about whether we should use\nmemory_order_relaxed or memory_order_release here:\n1. In posix standard, pthread_cond_wait/timedwait/signal/broadcast are all used as memory\n  synchronization functions, which should synchronize memory with respect to other threads.\n  For memory synchronization, I think it means we should provide some memory order fences,\n  like seq_cst or acquire/release fences.\n2. In implementation, __futex_wake_ex may cause system call or even context switch, which imposes\n  strong enoguh fences/barriers for memory synchronization. But I think we may not rely on the\n  implementation of __futex_wake_ex. So atomic_compare_exchange operation may be the proper place\n  to insert a release fence.\n3. |The woken thread cannot rely on seeing memory accesses performed before the signal call anyway;\n   |it might have spuriously woken up just before the signal was executed.\n   This rarely happens and I think no one will rely on it.\n\n4. It may cause problem if we lose the release fence.\n   A typical pthread_cond_wait example might like below:\n   // Consumer thread.\n   pthread_mutex_lock(\u0026mtx);\n   while (avail \u003d\u003d 0) {\n     pthread_cond_wait(\u0026cond, \u0026mtx);\n   }\n   // Work on available data.\n   pthread_mutex_unlock(\u0026mtx);\n   \n   // Product thread.\n   avail \u003d 1; // Of couse this can be protected by mtx, But I don\u0027t want to consider pthread_mutex_unlock\u0027s release fence here.\n   pthread_cond_signal(\u0026cond);\n\n  Suppose we don\u0027t have a release fence in pthread_cond_signal. So even after pthread_cond_signal(),\n  the consumer thread may still see \u0027avail\u0027 equals 0, then it will call pthread_cond_wait() again.\n  As no one guarantees to call pthread_cond_signal() again, the consumer thread takes risk of hanging\n  there.\n  So I think it doesn\u0027t matter if we can see that value is changed before pthread_cond_signal(),\n  but it does matter that we still can\u0027t see that value is changed after pthread_cond_signal(). \n\nAs a result of my consideration, I prefer to keep the release fence here.",
      "parentUuid": "7c3e00ec_9f04b33b",
      "range": {
        "startLine": 128,
        "startChar": 1,
        "endLine": 145,
        "endChar": 95
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc93d067_4bef053d",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T23:47:50Z",
      "side": 1,
      "message": "I agree with using add instead.  Good idea.\n\nI would not use the mask explicitly, since it greatly complicates the code.  Just please add a comment that this leaves the flags alone.\n\nThe code example you give is broken.  We don\u0027t need to try to half-way support it.  The assignment of 1 to avail races with the read of avail in the first thread.  That sort of data race is clearly disallowed by both Posix and C.  To fix the example, the assignment to avail should be done while holding mtx.  That fixes the memory ordering issue.\n\nEven if the accesses to avail were relaxed atomics, this wouldn\u0027t work.  Pthread_cond_wait could spuriously wake up just before pthread_cond_signal is executed by the other thread.  It would then see avail\u003d1, but wouldn\u0027t see the effect of the fence.\n\nIf we were to leave the fence there, it should be with a comment that it\u0027s there to defend against broken client code.  But that seems completely unhelpful to me since __futex_wake_ex has to include release semantics; it doesn\u0027t make sense unless at least the updates to the futex are visible to the woken thread.\n\nThere are ongoing debates about what Posix \"memory synchronization\" means.  They tend to be conducted on this mailing list:\n\nhttp://dir.gmane.org/gmane.comp.standards.posix.austin.c11-alignment\n\nIn my opinion, there is no reasonable and entirely consistent interpretation of the current standard.  (See my PLDI 05 paper for some justification for that statement.)\n\nI think the correct interpretation is that synchronization primitives that \"synchronize memory\" (and maybe some others) have essentially \"memory_order_seq_consistent\" semantics.  That doesn\u0027t mean much for pthread_cond_signal and friends,  since there is no way to tell whether they actually did anything.  The user can\u0027t tell whether a waiting thread was woken by pthread_cond_signal, or whether it was suspended just before the wait() and spuriously awoken just after the signal call completed.",
      "parentUuid": "1cc26457_7dc54b0f",
      "range": {
        "startLine": 128,
        "startChar": 1,
        "endLine": 145,
        "endChar": 95
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "318af32f_6dc4d515",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-09T21:36:08Z",
      "side": 1,
      "message": "Thanks for your explanation. I think I understand your reason for using memory_order_relaxed here more than before. I add some comment in the code, and you can review if it is correct and clear.",
      "parentUuid": "fc93d067_4bef053d",
      "range": {
        "startLine": 128,
        "startChar": 1,
        "endLine": 145,
        "endChar": 95
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc4910a5_a4bc0848",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T00:04:45Z",
      "side": 1,
      "message": "I would delete the comment.\nConditional variables provide no memory ordering guarantees beyond the underlying mutex.  That fact is not observable because wait can spuriously wake up early.",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 158,
        "endChar": 61
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc26457_dd1adf0d",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-05T22:56:25Z",
      "side": 1,
      "message": "Comment changed.\n|That fact is not observable because wait can spuriously wake up early.\nDo you mean pthread_cond_wait/timedwait don\u0027t need to provide memory synchronization on spurious wake up? I checked posix standard and couldn\u0027t find any word that it may not provide memory synchronization for spurious wake up.",
      "parentUuid": "fc4910a5_a4bc0848",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 158,
        "endChar": 61
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc93d067_aeff97ba",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T23:47:50Z",
      "side": 1,
      "message": "I don\u0027t think it actually makes sense to provide \"memory synchronization\" unless it\u0027s with another thread.  Certainly that\u0027s true in the C11 model.  There is a reading of Posix in which it does kind of make sense, but in that version everything includes a full fence, often on both sides, and all our code slows down tremendously.  Nobody implements that, for good reason.\n\nIn C11/C++11 a sequentially consistent operation on memory nobody else can see is a no-op.\n\nC++11 specifies condition variable synchronization correctly.  Wait is specified to acquire and release the mutex. Neither has an explicit synchronization clause.",
      "parentUuid": "1cc26457_dd1adf0d",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 158,
        "endChar": 61
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "318af32f_adc5dd10",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-09T21:36:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fc93d067_aeff97ba",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 158,
        "endChar": 61
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}