{
  "comments": [
    {
      "key": {
        "uuid": "3c400875_403d30ef",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T00:04:45Z",
      "side": 1,
      "message": "Could we do a drive-by fix and rename this, e.g. to nthreads?\n\nThis is not a counter.  And there are counters nearby, so this is really confusing.",
      "range": {
        "startLine": 126,
        "startChar": 17,
        "endLine": 126,
        "endChar": 24
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bc5dd861_99c69b19",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2015-02-05T00:33:18Z",
      "side": 1,
      "message": "(\u0027thread_count\u0027 would be our usual style.)",
      "parentUuid": "3c400875_403d30ef",
      "range": {
        "startLine": 126,
        "startChar": 17,
        "endLine": 126,
        "endChar": 24
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c8dbc43_511ed68f",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-05T22:56:25Z",
      "side": 1,
      "message": "Done. By the way, as __futex_wake_ex uses int, I didn\u0027t change the type to unsigned int.",
      "parentUuid": "bc5dd861_99c69b19",
      "range": {
        "startLine": 126,
        "startChar": 17,
        "endLine": 126,
        "endChar": 24
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c3e00ec_9f04b33b",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T00:04:45Z",
      "side": 1,
      "message": "Isn\u0027t this whole thing equivalent to\n\natomic_fetch_and_sub(cond_value_ptr, COND_COUNTER_STEP, memory_order_release)  ?\n\nAm I missing something?\n\nWe should really be operating on unsigned ints here, since\nwe are counting on 2s complement behavior for overflows.\n\nUnless we are trying to provide stronger than Posix guarantees (which I think we shouldn\u0027t), memory_order_relaxed is fine here, no matter which atomic operation you choose.  The woken thread cannot rely on seeing memory accesses performed before the signal call anyway; it might have spuriously woken up just before the signal was executed.  I would add something like that as a comment.\n\nI don\u0027t even think there is much danger of exposing client bugs, since the futex_wake_ex probably already has the fence anyway, and we can\u0027t eliminate that.",
      "range": {
        "startLine": 128,
        "startChar": 1,
        "endLine": 145,
        "endChar": 95
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc26457_7dc54b0f",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-05T22:56:25Z",
      "side": 1,
      "message": "In current implementation, it equals to atomic_fetch_and_sub, as the flags are all in lowest bits.\nI think it is more robust/readable to use COND_COUNTER_MASK to make sure it will not affect flags?\nBy the way, I don\u0027t know if there is any reason we should use subtraction instead of addition,\naddition is more intuitive to me, so I changed it.\npthread_cond_t value type is changed to unsigned int. \n\nI am not sure I truely understand you idea. Below is my consideration about whether we should use\nmemory_order_relaxed or memory_order_release here:\n1. In posix standard, pthread_cond_wait/timedwait/signal/broadcast are all used as memory\n  synchronization functions, which should synchronize memory with respect to other threads.\n  For memory synchronization, I think it means we should provide some memory order fences,\n  like seq_cst or acquire/release fences.\n2. In implementation, __futex_wake_ex may cause system call or even context switch, which imposes\n  strong enoguh fences/barriers for memory synchronization. But I think we may not rely on the\n  implementation of __futex_wake_ex. So atomic_compare_exchange operation may be the proper place\n  to insert a release fence.\n3. |The woken thread cannot rely on seeing memory accesses performed before the signal call anyway;\n   |it might have spuriously woken up just before the signal was executed.\n   This rarely happens and I think no one will rely on it.\n\n4. It may cause problem if we lose the release fence.\n   A typical pthread_cond_wait example might like below:\n   // Consumer thread.\n   pthread_mutex_lock(\u0026mtx);\n   while (avail \u003d\u003d 0) {\n     pthread_cond_wait(\u0026cond, \u0026mtx);\n   }\n   // Work on available data.\n   pthread_mutex_unlock(\u0026mtx);\n   \n   // Product thread.\n   avail \u003d 1; // Of couse this can be protected by mtx, But I don\u0027t want to consider pthread_mutex_unlock\u0027s release fence here.\n   pthread_cond_signal(\u0026cond);\n\n  Suppose we don\u0027t have a release fence in pthread_cond_signal. So even after pthread_cond_signal(),\n  the consumer thread may still see \u0027avail\u0027 equals 0, then it will call pthread_cond_wait() again.\n  As no one guarantees to call pthread_cond_signal() again, the consumer thread takes risk of hanging\n  there.\n  So I think it doesn\u0027t matter if we can see that value is changed before pthread_cond_signal(),\n  but it does matter that we still can\u0027t see that value is changed after pthread_cond_signal(). \n\nAs a result of my consideration, I prefer to keep the release fence here.",
      "parentUuid": "7c3e00ec_9f04b33b",
      "range": {
        "startLine": 128,
        "startChar": 1,
        "endLine": 145,
        "endChar": 95
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc4910a5_a4bc0848",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-05T00:04:45Z",
      "side": 1,
      "message": "I would delete the comment.\nConditional variables provide no memory ordering guarantees beyond the underlying mutex.  That fact is not observable because wait can spuriously wake up early.",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 158,
        "endChar": 61
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc26457_dd1adf0d",
        "filename": "libc/bionic/pthread_cond.cpp",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-05T22:56:25Z",
      "side": 1,
      "message": "Comment changed.\n|That fact is not observable because wait can spuriously wake up early.\nDo you mean pthread_cond_wait/timedwait don\u0027t need to provide memory synchronization on spurious wake up? I checked posix standard and couldn\u0027t find any word that it may not provide memory synchronization for spurious wake up.",
      "parentUuid": "fc4910a5_a4bc0848",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 158,
        "endChar": 61
      },
      "revId": "0899039fe1979ad042bcd5b47b2e496420d504f1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}