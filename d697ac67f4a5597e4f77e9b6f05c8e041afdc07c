{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f43598ec_8a885ce3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2020-11-23T20:57:39Z",
      "side": 1,
      "message": "These tests work for host glibc.  I haven\u0027t tried CF yet (in part because the build is broken).  I hope the results won\u0027t be different between the two implementations, though if they are... that gives us more reason not to use this.\n\nThe surprising thing that I see is \u0027ab\u0027 and \u0027ab*\u0027 match \u0027ab/cd\u0027, but \u0027ab/\u0027 and \u0027ab?\u0027 do not.  That may be hard enough to explain to convince me that using this is a bad idea.",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54556031_94a5166e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2020-11-24T13:50:16Z",
      "side": 1,
      "message": "Looks like our OpenBSD code and the host glibc do differ.  The below tests pass on host but fail on device.  My take is that it\u0027s an error that they\u0027re failing on device, though with how not well specified FNM_LEADING_DIR is, it may be intentional.  Luckily, these aren\u0027t cases that my ueventd code uses.\n\nbionic/tests/fnmatch_test.cpp:(97) Failure in test fnmatch.leading_dir\nExpected equality of these values:\n0\nfnmatch(\"*ab\", \"1/2/3/4/ab/cd\", 0x08)\nWhich is: 1\nbionic/tests/fnmatch_test.cpp:(110) Failure in test fnmatch.leading_dir\nExpected equality of these values:\n0\nfnmatch(\"ab*c\", \"ab/1/2/3/c/d/e\", 0x08)\nWhich is: 1\nfnmatch.leading_dir exited with exitcode 1.",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84132800_e20a6600",
        "filename": "tests/fnmatch_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-12-02T23:17:11Z",
      "side": 1,
      "message": "bionic/tests/fnmatch_test.cpp:(97) Failure in test fnmatch.leading_dir\nExpected equality of these values:\n0\nfnmatch(\"*ab\", \"1/2/3/4/ab/cd\", 0x08)\nWhich is: 1\n\n\n\nthis one confuses me compared to L92. i feel like if L92 isn\u0027t a match, there\u0027s no reasonable world where this is a match. (aiui, you\u0027re saying that glibc disagrees, but i\u0027m unconvinced about trying to take this as a \"fix\" to the BSDs as long as it doesn\u0027t make any sense to me. [sure, there\u0027s the argument that your feature that only exists for compatibility should be compatible, but when that feature seems so wrong -- or at least \"so inexplicable\" -- i can\u0027t help but think \"make it a no-op or remove it\" seems like the better fix!])\n\nmacOS returns 0 for both. which is at least self-consistent, even if it\u0027s what i\u0027d consider the \"both answers are wrong\" resolution. (that\u0027s weird though, we\u0027re BSD but consistently return 1 for both, which is self-consistent and makes some sense to me at least.)",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c8b5e03_2e115182",
        "filename": "tests/fnmatch_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2020-12-07T22:13:10Z",
      "side": 1,
      "message": "L92 doesn\u0027t match because the first * can\u0027t match /\u0027s due to FNM_PATHNAME.  That one should definitely not match.  If macOS returns 0 for L92, then that\u0027s profoundly broken.\n\nL97 doesn\u0027t have FNM_PATHNAME, so the prefix 1/2/3/4/ is matched by the *.  That leaves us with `ab` remaining in the pattern and `ab/cd` remaining in the string, which is exactly L95, which does match on all platforms.\n\nIf L95, which has a pattern ending in neither * or /, matches subdirectories, then I would expect that subdirectory matching behavior at the end of any string that ends in neither * or / with FNM_LEADING_DIR.  That is not the case in our implementation, and why I think glibc is right.",
      "parentUuid": "84132800_e20a6600",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfaea5d1_68ea9552",
        "filename": "tests/fnmatch_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-12-08T00:34:55Z",
      "side": 1,
      "message": "ah, i don\u0027t think i realized that \"dir\" matches \"dir/anything\", though, yes, that makes sense when you point it out! i should add that as one of the regular tests if nothing else!\n\nso, yes, given that i have to then accept that L97 does seem like a bug in our^WNetBSD\u0027s implementation...",
      "parentUuid": "2c8b5e03_2e115182",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "368c4318_732d904d",
        "filename": "tests/fnmatch_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-12-02T23:17:11Z",
      "side": 1,
      "message": "bionic/tests/fnmatch_test.cpp:(110) Failure in test fnmatch.leading_dir\nExpected equality of these values:\n0\nfnmatch(\"ab*c\", \"ab/1/2/3/c/d/e\", 0x08)\nWhich is: 1\n\n\nhere too, our result makes more sense than glibc\u0027s?",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38b8129f_dc29d70d",
        "filename": "tests/fnmatch_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2020-12-07T22:13:10Z",
      "side": 1,
      "message": "Same as above, in my mind this is the same as L95 and L97.  The `ab` in the pattern matches `ab in the string, then the `*` in the pattern matches `/1/2/3/` in the string, which leaves us with `c` in the pattern and `c/d/e` in the string, which is the same case as L95.\n\nMaybe there\u0027s some greedy vs not-greedy matching happening here that\u0027s causing the issue?",
      "parentUuid": "368c4318_732d904d",
      "revId": "d697ac67f4a5597e4f77e9b6f05c8e041afdc07c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}