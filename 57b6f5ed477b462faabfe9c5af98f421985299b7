{
  "comments": [
    {
      "key": {
        "uuid": "05fccdc3_246df216",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-24T23:05:05Z",
      "side": 1,
      "message": "I\u0027m a bit concerned about anything that increases thread creation/destruction overhead, given the lengths people tend to go to to avoid creating threads.  But Elliott is clearly right that this currently unlikely to be low hanging fruit, especially given the low limit.  I agree it\u0027s fine for now.",
      "range": {
        "startLine": 68,
        "startChar": 27,
        "endLine": 68,
        "endChar": 51
      },
      "revId": "57b6f5ed477b462faabfe9c5af98f421985299b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "254471e8_fd9207ed",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2015-02-24T23:18:30Z",
      "side": 1,
      "message": "we used to take two global locks *and* have this loop :-)",
      "parentUuid": "05fccdc3_246df216",
      "range": {
        "startLine": 68,
        "startChar": 27,
        "endLine": 68,
        "endChar": 51
      },
      "revId": "57b6f5ed477b462faabfe9c5af98f421985299b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6542e9dd_bf4a376d",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 7
      },
      "lineNbr": 69,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-24T23:05:05Z",
      "side": 1,
      "message": "I don\u0027t think this is quite correct yet, though failures are extremely unlikely.  The read of key_destructor potentially races with key_create.  This seems to be unavoidably true, independent of memory order sepcifications.  I think it\u0027s (mostly) fixable by doing the non-null destructor test last.  At that point, we know that we have valid non-null data, which could only have gotten there if someone passed us the key, and that (almost) implies a happens-before ordering.\n\n(almost: I think this assumes the absence of a non-trivial memory_order_consume implementation, which is currently a safe assumption.)\n\nIf I\u0027m correct, this also requires a comment.",
      "range": {
        "startLine": 69,
        "startChar": 60,
        "endLine": 69,
        "endChar": 80
      },
      "revId": "57b6f5ed477b462faabfe9c5af98f421985299b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "650d89bb_ca34e3d6",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 7
      },
      "lineNbr": 69,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-02-25T00:00:26Z",
      "side": 1,
      "message": "I am a little confused. I can explain my consideration here and you can see any place needs discussion.\n1. We don\u0027t need to worry about key_data[i].data and key_data[i].seq here, as they are only set and used in current thread.\n2. If some other threads create a new key while current thread is exiting, it may see the key as created but key_destructor is null. But it doesn\u0027t matter, it just works as if current thread exit before the key is created. After all, we don\u0027t have responsibility to make synchronization between creating/deleting keys and using keys.",
      "parentUuid": "6542e9dd_bf4a376d",
      "range": {
        "startLine": 69,
        "startChar": 60,
        "endLine": 69,
        "endChar": 80
      },
      "revId": "57b6f5ed477b462faabfe9c5af98f421985299b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e526d94e_73a860a0",
        "filename": "libc/bionic/pthread_key.cpp",
        "patchSetId": 7
      },
      "lineNbr": 69,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-02-25T00:27:51Z",
      "side": 1,
      "message": "1. Correct.  But I think we can take advantage of them to resolve 2.\n\n2. The problem is just that key_destructor can be concurrently read while it\u0027s being set.  Since it\u0027s not atomic, C++ does not allow that; it results in undefined behavior.  By the language rules, it can, for example, see half the bits of the destructor updated and the other half null.  That\u0027s unlikely to happen on our hardware.  Somewhat more likely failure scenarios:\n\na) Since there is no ordering, the destructor can read as on old, previously replaced value.  After thinking about this more, that may be a real concern.\n\nb) The compiler performs some weird optimization, knowing that key_destructor can\u0027t change asynchronously, and reading it multiple times is OK.  The program crashes because the assumption doesn\u0027t hold.  Currently very unlikely, though we can construct semiplausible scenarios along these lines.\n\nc) In the distant future bionic and tsan are solid enough to run tsan over this code.  It fails because there is a data race.\n\nThus we don\u0027t want to access the destructor unless this thread has used this key, in which case the destructor access should not race.",
      "parentUuid": "650d89bb_ca34e3d6",
      "range": {
        "startLine": 69,
        "startChar": 60,
        "endLine": 69,
        "endChar": 80
      },
      "revId": "57b6f5ed477b462faabfe9c5af98f421985299b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}