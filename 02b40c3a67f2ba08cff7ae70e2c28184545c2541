{
  "comments": [
    {
      "key": {
        "uuid": "baae230c_9e3b0c42",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2019-05-20T14:21:14Z",
      "side": 1,
      "message": "This change ought to be accompanied by unit and/or CTS test changes.",
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28edcf11_723ac5c4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-05-21T12:02:03Z",
      "side": 1,
      "message": "I\u0027ve replied in the other CL.",
      "parentUuid": "baae230c_9e3b0c42",
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "581ea67a_9b2f42e5",
        "filename": "linker/linker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2566,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2019-05-20T14:21:14Z",
      "side": 1,
      "message": "This looks like it breaks isolation and we might get different behaviour based on changes in global ordering, which makes me a bit wary.\n\nBut first I need to check my understanding of the scenario: The anonymous namespace is used when we cannot determine the caller, hence we only have the process global state to go on, and also a library path judging from the call site [1]. That\u0027s apparently not enough - the loaded code assumes some libraries are available that we try to get through the first classloader-namespace(?) being created here. Is that about right?\n\nIf so, do we know more specifically what the loaded code needs? In http://b/130623656#comment11 it wants to load an .so from the app\u0027s own directory - can\u0027t we determine that at app startup?\n\n[1] http://cs/aosp-master/system/core/libnativeloader/library_namespaces.cpp?l\u003d160-161\u0026rcl\u003dde725e6e757ec780861be4d5b85d653211be9fa2",
      "range": {
        "startLine": 2565,
        "startChar": 5,
        "endLine": 2566,
        "endChar": 24
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26f6bdd8_be9e303b",
        "filename": "linker/linker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2566,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-05-21T12:02:03Z",
      "side": 1,
      "message": "Your understanding is correct. So, IMO, there has to be some heuristic on anonymous namespace cause there is not much hint (the caller). And the heuristic is that \"if we don\u0027t know the caller, assume that it is from the first app classloader\".\n\nSo, I think we actually don\u0027t need to isolate anonymous namespace from other classloader-namespace namespaces. If the caller was available, the lib should have been loaded into one of the named namespaces (which probably would be the first one).",
      "parentUuid": "581ea67a_9b2f42e5",
      "range": {
        "startLine": 2565,
        "startChar": 5,
        "endLine": 2566,
        "endChar": 24
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a2248887_531d707e",
        "filename": "linker/linker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2566,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2019-05-21T13:47:18Z",
      "side": 1,
      "message": "The significant difference between knowing the caller and doing this is in the word \"first\". Maybe it\u0027s just me not understanding app native loading well enough, but how do ascertain that the first namespace loaded with these criteria (through ANDROID_NAMESPACE_TYPE_UNTRUSTED - you\u0027re also dropping the condition that the library path should be nonempty in the other CL) is a good one to use for this? It seems coincidental to me. Brittle too - even if we can argue it does the right thing now, it means relying on a global characteristic of the whole loader setup, which is hard to ensure (which also means tests become all the more important).\n\nI was rather hoping for something along the lines of: \"if we don\u0027t know the caller, use a namespace with well known parameters x, y, z - no more and no less\". That\u0027s why I wondered what we know about what x, y and z should be. Getting the app .so lib directory into the search path is one of them, setting up all the usual library links is of course another. Are there more? Is it only in the \"first\" app classloader namespace that we can find them?\n\nTaking the approach further, that namespace with x, y and z would be the most suitable for the \"main\" app namespace, and it ought to be the parent for even the first classloader namespace. It would also help address the issue of the namespace to use for app binaries (cf http://b/130788466#comment18), because there we don\u0027t have any classloader namespace to start from.",
      "parentUuid": "26f6bdd8_be9e303b",
      "range": {
        "startLine": 2565,
        "startChar": 5,
        "endLine": 2566,
        "endChar": 24
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47196e7e_7038338a",
        "filename": "linker/linker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2566,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-05-21T14:19:40Z",
      "side": 1,
      "message": "\u003e \"if we don\u0027t know the caller, use a namespace with well known parameters x, y, z - no more and no less\n\nThis is done inside the linker. And it shouldn\u0027t (and can\u0027t) know anything about the characteristics of the linker, because the namespaces are all created outside of the linker. It doesn\u0027t know whether or not a search path is for an app. To the linker, the namespaces are the same (perhaps except for the default ns). So,there must be a hint from \"the outside\", and ANDROID_NAMESPACE_TYPE_UNTRUSTED is it. Previously, without giving a hint, we explicitly created a new namespace just for that case, but fundamentally that is the same; linker anyway rely on libnativeloader to teach it the namespace that it should use when caller isn\u0027t identifiable.\n\nWhether the hinted namespace is correctly configured or not, and whether the hint is correctly given or not are all the responsibilities of libnativeloader, not the linker.",
      "parentUuid": "a2248887_531d707e",
      "range": {
        "startLine": 2565,
        "startChar": 5,
        "endLine": 2566,
        "endChar": 24
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4dcde391_ddb9d289",
        "filename": "linker/linker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2566,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2019-05-22T13:07:49Z",
      "side": 1,
      "message": "Sure, but I\u0027m discussing the larger problem encompassing both CLs in this topic. What parts of it goes into the linker is more of an implementation detail. Sorry for the confusion of opening the topic on the wrong CL.\n\nI think my question about those x, y and z still is very relevant to figure out the right way forward for the anonymous namespace issue.\n\nAs for the linker interface, I prefer the old one, i.e. telling the linker to specifically use a certain namespace for this. It\u0027s more explicit and doesn\u0027t encode the notion of using the first namespace in the linker. It might even be reasonable to drop the g_anonymous_namespace_initialized check in the old code and leave that too to libnativeloader.",
      "parentUuid": "47196e7e_7038338a",
      "range": {
        "startLine": 2565,
        "startChar": 5,
        "endLine": 2566,
        "endChar": 24
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed1b2ad5_954ef8bc",
        "filename": "linker/linker.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2019-05-20T14:21:14Z",
      "side": 1,
      "message": "This is subordinate to my general comment below about this approach, but this should also explain what the flag actually entails.",
      "range": {
        "startLine": 160,
        "startChar": 2,
        "endLine": 162,
        "endChar": 65
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56a33dfd_6fd893fe",
        "filename": "linker/linker.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-05-21T12:02:03Z",
      "side": 1,
      "message": "I am confused. The description explains what the flag is for: shared libs from apps and libs for unknown caller of dlopen().",
      "parentUuid": "ed1b2ad5_954ef8bc",
      "range": {
        "startLine": 160,
        "startChar": 2,
        "endLine": 162,
        "endChar": 65
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7d26553_8c1555c0",
        "filename": "linker/linker.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2019-05-21T13:47:18Z",
      "side": 1,
      "message": "What I meant is that it would also be helpful to know what the flag makes the linker do, i.e. effectively making the namespace a candidate for becoming the anonymous namespace.",
      "parentUuid": "56a33dfd_6fd893fe",
      "range": {
        "startLine": 160,
        "startChar": 2,
        "endLine": 162,
        "endChar": 65
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e3e7f7c_47d90c89",
        "filename": "linker/linker.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-05-21T14:19:40Z",
      "side": 1,
      "message": "anonymous namespace is a concept private to the linker. (we ideally need to remove APIs like android_init_anonymous_namespace. I left that just because there are some existing test code using it). The description already explains that a namespace flagged with this is used to load libraries when the caller cannot be determined.",
      "parentUuid": "a7d26553_8c1555c0",
      "range": {
        "startLine": 160,
        "startChar": 2,
        "endLine": 162,
        "endChar": 65
      },
      "revId": "02b40c3a67f2ba08cff7ae70e2c28184545c2541",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}